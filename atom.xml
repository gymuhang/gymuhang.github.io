<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>旺仔-空间</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-22T03:22:35.938Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Gordon gy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nacos 实战</title>
    <link href="http://yoursite.com/wiki/nacos/nacos/"/>
    <id>http://yoursite.com/wiki/nacos/nacos/</id>
    <published>2020-04-22T01:24:57.128Z</published>
    <updated>2020-04-22T03:22:35.938Z</updated>
    
    <content type="html"><![CDATA[<p>一款异步的事件驱动的网络应用程序框架</p><p>阻塞   发起  —-》阻塞…. 阻塞  —–》完成</p><p>   检查…检查—-》阻塞—-》完成</p><p>​    阻塞与非阻塞是进程在访问数据的时候，数据是否准备就绪的处理方式，数据没准备好，要么等待数据准备好处理，要么直接返回即不处理</p><p>同步    <strong>双方的动作是经过双方协调的，步调一致的</strong></p><p>异步    <strong>双方并不需要协调，都可以随意进行各自的操作</strong></p><p>​    同步与异步都是基于应用程序和操作系统处理IO时间采用的方式，要么应用程序直接参与IO操作，要么IO操作交给操作系统去处理，应用程序只要等待通知</p><p>事件驱动：指在持续事务管理过程中，进行决策的一种策略，即跟随当前时间点上出现的事件，调动可用资源，执行相关任务，使不断出现的问题得以解决，防止事务堆积。（就是回调）</p><p>bio：阻塞同步io</p><p>nio：非阻塞io</p><p>aio：非阻塞异步io</p><p>​    <strong>为什么Netty使用NIO而不是AIO？</strong></p><ol><li><p>Netty不看重Windows上的使用，在Linux系统上，AIO的底层实现仍使用EPOLL，没有很好实现AIO，因此在性能上没有明显的优势，而且被JDK封装了一层不容易深度优化</p></li><li><p>Netty整体架构是reactor模型, 而AIO是proactor模型, 混合在一起会非常混乱,把AIO也改造成reactor模型看起来是把epoll绕个弯又绕回来</p></li><li><p>AIO还有个缺点是接收数据需要预先分配缓存, 而不是NIO那种需要接收时才需要分配缓存, 所以对连接数量非常大但流量小的情况, 内存浪费很多</p></li><li><p>Linux上AIO不够成熟，处理回调结果速度跟不到处理需求，比如外卖员太少，顾客太多，供不应求，造成处理速度有瓶颈（待验证）</p><p>BIO是面向流的，一位置每次从流中读取字节，直至读取完全部字节，他们没有缓存在任何地方，因此是不能前后移动流中数据，需要移动或者操作的话需要将其缓存到缓冲区。</p><p>NIO是面向缓冲区的，数据读取到一个稍后处理的缓冲区，当然可以前后移动或者操作缓冲区数据。</p></li></ol><h2 id="1-组件"><a href="#1-组件" class="headerlink" title="1.组件"></a>1.组件</h2><h3 id="1-Channel"><a href="#1-Channel" class="headerlink" title="1.Channel"></a>1.Channel</h3><p>​        Java NIO的基本构造，代表一个到实体的开放连接，如读操作和写操作</p><h3 id="2-回调"><a href="#2-回调" class="headerlink" title="2.回调"></a>2.回调</h3><p>​        异步处理的后续操作</p><h3 id="3-Future"><a href="#3-Future" class="headerlink" title="3.Future"></a>3.Future</h3><p>​        提供了另一种操作完成时通知应用程序的方式，可以看作是异步操作结果的占位符，它在未来的某个时刻完成，并提供对其结果的访问，相对于jdk netty提供了自己的实现ChannelFuture 用的是ChannelFutureListener，即监听器</p><h3 id="4-事件和ChannelHandler"><a href="#4-事件和ChannelHandler" class="headerlink" title="4.事件和ChannelHandler"></a>4.事件和ChannelHandler</h3><p>​    事件就是 网络事件的出入站等，而ChannelHandler 则是对应具体事件的处理</p><h3 id="5-放在一起"><a href="#5-放在一起" class="headerlink" title="5.放在一起"></a>5.放在一起</h3><p>​     Netty的异步编程模型建立在Future和回调上，并将事件派发到ChannelHandlerf方法。</p><p>​    触发事件 通过 抽象的Selector 进行派发代码，在内部为每个channel 分配EventLoop （线程驱动），来处理所有的事件 </p><h1 id="2-第一个应用"><a href="#2-第一个应用" class="headerlink" title="2.第一个应用"></a>2.第一个应用</h1><h1 id="3-netty的组件和设计"><a href="#3-netty的组件和设计" class="headerlink" title="3.netty的组件和设计"></a>3.netty的组件和设计</h1><h2 id="1-Channel-EventLoop-ChannelFuture-网络抽象"><a href="#1-Channel-EventLoop-ChannelFuture-网络抽象" class="headerlink" title="1.Channel EventLoop  ChannelFuture  网络抽象"></a>1.Channel EventLoop  ChannelFuture  网络抽象</h2><p>​        Channel   一个连接 socket  （提供了很多默认实现）</p><p>​        EventLoop 控制流、多线程、并发  （相等于线程，EventLoop 相当于线程池）一个Channel  绑定一个         </p><p>​    EventLoop ，但是一个EventLoop  可能会分配给一个或多个Channel   </p><p>​        ChannelFuture   异步通知</p><h2 id="2-ChannelHandler-ChannelPipeline-管理数据流以及执行应用程序处理逻辑"><a href="#2-ChannelHandler-ChannelPipeline-管理数据流以及执行应用程序处理逻辑" class="headerlink" title="2.ChannelHandler ChannelPipeline  管理数据流以及执行应用程序处理逻辑"></a>2.ChannelHandler ChannelPipeline  管理数据流以及执行应用程序处理逻辑</h2><p>​        ChannelHandler  </p><p>​            ①入站和出站的数据的程序逻辑容器，②编解码，③异常通知，④channel编程活动或非活动的通知，⑤</p><p>​            注册Eventloop，或者注销  Eventloop的通知，⑥用户自定义的事件通知</p><p>​            常用的   ChannelHandlerAdapter </p><p>​                    ChannelInboundHandlerAdapter</p><p>​                    ChannelOutboundHandlerAdapter</p><p>​                    ChannelDuplexHandler</p><p>​                    编码器、解码器</p><p>​                    SimpleChannelInboundHandler<t> T 需要处理的数据类型  ctx是可以继续传递下去</t></p><p>​        ChannelPipeline   （拦截过滤器实现）</p><p>​            是ChannelHandler  处理链的容器 出站和入站方向相反</p><p>​        引导 </p><p>​            为应用程序网络层配置提供容器，将进程绑定和端口或者将进程连接到某个指定主机的指定端口进程，面</p><p>​        向连接的协议，如 tcp</p><p>​            Bootstrap   一个EventLoopGroup</p><p>​            ServerBootstrap  两个EventLoopGroup （当然也可以共用一个） 一个用来监听服务，一个用来处理传入</p><p>​            客户端的连接</p><h1 id="4-传输"><a href="#4-传输" class="headerlink" title="4.传输"></a>4.传输</h1><p>​    OIO（阻塞）、NIO（非阻塞）、Local（JVM内部的异步通信）、Embedded（测试channelHandler）</p><p>​    netty的api 比较统一，只需要少量修改</p><h2 id="1-传输的api"><a href="#1-传输的api" class="headerlink" title="1.传输的api"></a>1.传输的api</h2><p>​    channel  线程安全的</p><p>​        EventLoop eventLoop(); 返回分配的eventLoop</p><p>​        ChannelPipeline pipeline(); 返回分配的ChannelPipeline </p><p>​        boolean isActive(); 是否是活动的</p><p>​        SocketAddress localAddress(); 返回本地的 SocketAddress </p><p>​        SocketAddress remoteAddress(); 返回远程的 SocketAddress </p><p>​        ChannelFuture write(Object var1); 将数据写到远程节点，这个数据传递给 ChannelPipeline 写队列的第一个</p><p>​        Channel flush(); 将之前写的数据 清空缓冲区数据 冲刷到 底层传输</p><p>​        ChannelFuture writeAndFlush(Object var1); 写然后冲刷</p><h2 id="2-内置的传输"><a href="#2-内置的传输" class="headerlink" title="2.内置的传输"></a>2.内置的传输</h2><p>​        提供的开箱可用的传输</p><p>​        1.NIO  io.netty.channel.socket.nio     java NIO为基础</p><p>​            选择器背后就是个注册表，当channel 发生变化时，得到通知，可能的变化：</p><p>​                新的channel已经接受并且就绪 OP_ACCEPT</p><p>​                channel连接已经完成 OP_CONNECT</p><p>​                channel有已经就绪的可供读取的数据  OP_READ</p><p>​                channel可用于写数据    OP_WRITE</p><p>​                zero-copy（直接将数据从文件移动到网络接口）</p><p>​        2.Epoll io.netty.channel.epoll      基于JNI驱动的epoll()和非阻塞IO，在linux上更快，比NIO更快</p><p>​            linux jdk nio 使用了这一特性，但是netty 做了自己的统一封装 （使用了更加轻量的中断）比jdk 更高效</p><p>​            替换的话 Epoll 的serverSocket和EvevtLoopGroup    </p><p>​        3.OIO io.netty.channme.socket.oio 使用java.net 包的阻塞流</p><p>​            适用于某些阻塞的调用库（jdbc）等</p><p>​        4.Local io.netty.channel.local  在JVM内部通过管道进行通信的本地传输​            </p><p>​        5.Embedded io.netty.channel.embedded  Embedded传输，允许使用channelhandler不是真正的网络传输，为</p><p>​          了测试channelHandler</p><table><thead><tr><th>传输</th><th>TCP</th><th>UDP</th><th>SCT</th><th>UDT</th></tr></thead><tbody><tr><td>NIO</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Epoll（仅linux）</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>OIO</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一款异步的事件驱动的网络应用程序框架&lt;/p&gt;
&lt;p&gt;阻塞   发起  —-》阻塞…. 阻塞  —–》完成&lt;/p&gt;
&lt;p&gt;   检查…检查—-》阻塞—-》完成&lt;/p&gt;
&lt;p&gt;​    阻塞与非阻塞是进程在访问数据的时候，数据是否准备就绪的处理方式，数据没准备好，要么等待数据准
      
    
    </summary>
    
      <category term="nacos" scheme="http://yoursite.com/categories/nacos/"/>
    
    
  </entry>
  
  <entry>
    <title>netty源码解析</title>
    <link href="http://yoursite.com/wiki/netty/netty-action/"/>
    <id>http://yoursite.com/wiki/netty/netty-action/</id>
    <published>2020-04-22T01:24:57.128Z</published>
    <updated>2020-04-22T03:20:33.248Z</updated>
    
    <content type="html"><![CDATA[<p>一款异步的事件驱动的网络应用程序框架</p><p>阻塞   发起  —-》阻塞…. 阻塞  —–》完成</p><p>   检查…检查—-》阻塞—-》完成</p><p>​    阻塞与非阻塞是进程在访问数据的时候，数据是否准备就绪的处理方式，数据没准备好，要么等待数据准备好处理，要么直接返回即不处理</p><p>同步    <strong>双方的动作是经过双方协调的，步调一致的</strong></p><p>异步    <strong>双方并不需要协调，都可以随意进行各自的操作</strong></p><p>​    同步与异步都是基于应用程序和操作系统处理IO时间采用的方式，要么应用程序直接参与IO操作，要么IO操作交给操作系统去处理，应用程序只要等待通知</p><p>事件驱动：指在持续事务管理过程中，进行决策的一种策略，即跟随当前时间点上出现的事件，调动可用资源，执行相关任务，使不断出现的问题得以解决，防止事务堆积。（就是回调）</p><p>bio：阻塞同步io</p><p>nio：非阻塞io</p><p>aio：非阻塞异步io</p><p>​    <strong>为什么Netty使用NIO而不是AIO？</strong></p><ol><li><p>Netty不看重Windows上的使用，在Linux系统上，AIO的底层实现仍使用EPOLL，没有很好实现AIO，因此在性能上没有明显的优势，而且被JDK封装了一层不容易深度优化</p></li><li><p>Netty整体架构是reactor模型, 而AIO是proactor模型, 混合在一起会非常混乱,把AIO也改造成reactor模型看起来是把epoll绕个弯又绕回来</p></li><li><p>AIO还有个缺点是接收数据需要预先分配缓存, 而不是NIO那种需要接收时才需要分配缓存, 所以对连接数量非常大但流量小的情况, 内存浪费很多</p></li><li><p>Linux上AIO不够成熟，处理回调结果速度跟不到处理需求，比如外卖员太少，顾客太多，供不应求，造成处理速度有瓶颈（待验证）</p><p>BIO是面向流的，一位置每次从流中读取字节，直至读取完全部字节，他们没有缓存在任何地方，因此是不能前后移动流中数据，需要移动或者操作的话需要将其缓存到缓冲区。</p><p>NIO是面向缓冲区的，数据读取到一个稍后处理的缓冲区，当然可以前后移动或者操作缓冲区数据。</p></li></ol><h2 id="1-组件"><a href="#1-组件" class="headerlink" title="1.组件"></a>1.组件</h2><h3 id="1-Channel"><a href="#1-Channel" class="headerlink" title="1.Channel"></a>1.Channel</h3><p>​        Java NIO的基本构造，代表一个到实体的开放连接，如读操作和写操作</p><h3 id="2-回调"><a href="#2-回调" class="headerlink" title="2.回调"></a>2.回调</h3><p>​        异步处理的后续操作</p><h3 id="3-Future"><a href="#3-Future" class="headerlink" title="3.Future"></a>3.Future</h3><p>​        提供了另一种操作完成时通知应用程序的方式，可以看作是异步操作结果的占位符，它在未来的某个时刻完成，并提供对其结果的访问，相对于jdk netty提供了自己的实现ChannelFuture 用的是ChannelFutureListener，即监听器</p><h3 id="4-事件和ChannelHandler"><a href="#4-事件和ChannelHandler" class="headerlink" title="4.事件和ChannelHandler"></a>4.事件和ChannelHandler</h3><p>​    事件就是 网络事件的出入站等，而ChannelHandler 则是对应具体事件的处理</p><h3 id="5-放在一起"><a href="#5-放在一起" class="headerlink" title="5.放在一起"></a>5.放在一起</h3><p>​     Netty的异步编程模型建立在Future和回调上，并将事件派发到ChannelHandlerf方法。</p><p>​    触发事件 通过 抽象的Selector 进行派发代码，在内部为每个channel 分配EventLoop （线程驱动），来处理所有的事件 </p><h1 id="2-第一个应用"><a href="#2-第一个应用" class="headerlink" title="2.第一个应用"></a>2.第一个应用</h1><h1 id="3-netty的组件和设计"><a href="#3-netty的组件和设计" class="headerlink" title="3.netty的组件和设计"></a>3.netty的组件和设计</h1><h2 id="1-Channel-EventLoop-ChannelFuture-网络抽象"><a href="#1-Channel-EventLoop-ChannelFuture-网络抽象" class="headerlink" title="1.Channel EventLoop  ChannelFuture  网络抽象"></a>1.Channel EventLoop  ChannelFuture  网络抽象</h2><p>​        Channel   一个连接 socket  （提供了很多默认实现）</p><p>​        EventLoop 控制流、多线程、并发  （相等于线程，EventLoop 相当于线程池）一个Channel  绑定一个         </p><p>​    EventLoop ，但是一个EventLoop  可能会分配给一个或多个Channel   </p><p>​        ChannelFuture   异步通知</p><h2 id="2-ChannelHandler-ChannelPipeline-管理数据流以及执行应用程序处理逻辑"><a href="#2-ChannelHandler-ChannelPipeline-管理数据流以及执行应用程序处理逻辑" class="headerlink" title="2.ChannelHandler ChannelPipeline  管理数据流以及执行应用程序处理逻辑"></a>2.ChannelHandler ChannelPipeline  管理数据流以及执行应用程序处理逻辑</h2><p>​        ChannelHandler  </p><p>​            ①入站和出站的数据的程序逻辑容器，②编解码，③异常通知，④channel编程活动或非活动的通知，⑤</p><p>​            注册Eventloop，或者注销  Eventloop的通知，⑥用户自定义的事件通知</p><p>​            常用的   ChannelHandlerAdapter </p><p>​                    ChannelInboundHandlerAdapter</p><p>​                    ChannelOutboundHandlerAdapter</p><p>​                    ChannelDuplexHandler</p><p>​                    编码器、解码器</p><p>​                    SimpleChannelInboundHandler<t> T 需要处理的数据类型  ctx是可以继续传递下去</t></p><p>​        ChannelPipeline   （拦截过滤器实现）</p><p>​            是ChannelHandler  处理链的容器 出站和入站方向相反</p><p>​        引导 </p><p>​            为应用程序网络层配置提供容器，将进程绑定和端口或者将进程连接到某个指定主机的指定端口进程，面</p><p>​        向连接的协议，如 tcp</p><p>​            Bootstrap   一个EventLoopGroup</p><p>​            ServerBootstrap  两个EventLoopGroup （当然也可以共用一个） 一个用来监听服务，一个用来处理传入</p><p>​            客户端的连接</p><h1 id="4-传输"><a href="#4-传输" class="headerlink" title="4.传输"></a>4.传输</h1><p>​    OIO（阻塞）、NIO（非阻塞）、Local（JVM内部的异步通信）、Embedded（测试channelHandler）</p><p>​    netty的api 比较统一，只需要少量修改</p><h2 id="1-传输的api"><a href="#1-传输的api" class="headerlink" title="1.传输的api"></a>1.传输的api</h2><p>​    channel  线程安全的</p><p>​        EventLoop eventLoop(); 返回分配的eventLoop</p><p>​        ChannelPipeline pipeline(); 返回分配的ChannelPipeline </p><p>​        boolean isActive(); 是否是活动的</p><p>​        SocketAddress localAddress(); 返回本地的 SocketAddress </p><p>​        SocketAddress remoteAddress(); 返回远程的 SocketAddress </p><p>​        ChannelFuture write(Object var1); 将数据写到远程节点，这个数据传递给 ChannelPipeline 写队列的第一个</p><p>​        Channel flush(); 将之前写的数据 清空缓冲区数据 冲刷到 底层传输</p><p>​        ChannelFuture writeAndFlush(Object var1); 写然后冲刷</p><h2 id="2-内置的传输"><a href="#2-内置的传输" class="headerlink" title="2.内置的传输"></a>2.内置的传输</h2><p>​        提供的开箱可用的传输</p><p>​        1.NIO  io.netty.channel.socket.nio     java NIO为基础</p><p>​            选择器背后就是个注册表，当channel 发生变化时，得到通知，可能的变化：</p><p>​                新的channel已经接受并且就绪 OP_ACCEPT</p><p>​                channel连接已经完成 OP_CONNECT</p><p>​                channel有已经就绪的可供读取的数据  OP_READ</p><p>​                channel可用于写数据    OP_WRITE</p><p>​                zero-copy（直接将数据从文件移动到网络接口）</p><p>​        2.Epoll io.netty.channel.epoll      基于JNI驱动的epoll()和非阻塞IO，在linux上更快，比NIO更快</p><p>​            linux jdk nio 使用了这一特性，但是netty 做了自己的统一封装 （使用了更加轻量的中断）比jdk 更高效</p><p>​            替换的话 Epoll 的serverSocket和EvevtLoopGroup    </p><p>​        3.OIO io.netty.channme.socket.oio 使用java.net 包的阻塞流</p><p>​            适用于某些阻塞的调用库（jdbc）等</p><p>​        4.Local io.netty.channel.local  在JVM内部通过管道进行通信的本地传输​            </p><p>​        5.Embedded io.netty.channel.embedded  Embedded传输，允许使用channelhandler不是真正的网络传输，为</p><p>​          了测试channelHandler</p><table><thead><tr><th>传输</th><th>TCP</th><th>UDP</th><th>SCT</th><th>UDT</th></tr></thead><tbody><tr><td>NIO</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Epoll（仅linux）</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>OIO</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一款异步的事件驱动的网络应用程序框架&lt;/p&gt;
&lt;p&gt;阻塞   发起  —-》阻塞…. 阻塞  —–》完成&lt;/p&gt;
&lt;p&gt;   检查…检查—-》阻塞—-》完成&lt;/p&gt;
&lt;p&gt;​    阻塞与非阻塞是进程在访问数据的时候，数据是否准备就绪的处理方式，数据没准备好，要么等待数据准
      
    
    </summary>
    
      <category term="netty" scheme="http://yoursite.com/categories/netty/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty-ByteBuf</title>
    <link href="http://yoursite.com/wiki/netty/Netty-new%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/wiki/netty/Netty-new笔记/</id>
    <published>2020-02-24T00:31:59.857Z</published>
    <updated>2020-04-22T11:44:51.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><blockquote><ul><li><p>内存的类别有哪些？</p></li><li><p>如何减少多线程内存分配之间的竞争？</p></li><li>不同大小的内存是如何进行分配的？</li></ul></blockquote><h4 id="ByteBuf-结构及重要API"><a href="#ByteBuf-结构及重要API" class="headerlink" title="ByteBuf 结构及重要API"></a>ByteBuf 结构及重要API</h4><ul><li><p>Bytebuf 结构</p><p><img src="/Users/guoyin/Library/Application Support/typora-user-images/image-20200223095544828.png" alt="image-20200223095544828"></p><ul><li>readerIndex 读指针</li><li>writerIndex 写指针</li><li>capacity 容量</li><li>maxCapacity 最大容量</li></ul></li></ul><h4 id="ByteBuf-分类"><a href="#ByteBuf-分类" class="headerlink" title="ByteBuf 分类"></a>ByteBuf 分类</h4><p><img src="/Users/guoyin/Library/Application Support/typora-user-images/image-20200223102244363.png" alt="image-20200223102244363"></p><ul><li><p>Pooled 和 Unpooled</p><blockquote><ul><li><p>Pooled </p><p>从预先分配好的一块内存，去取一段连续内存封装成ByteBuf, 返回给应用程序</p></li><li><p>Unpooled</p><p>每次进行内存分配时，直接调用系统API，向操作系统申请一块内存。</p></li></ul></blockquote></li><li><p>Unsafe 和 非Unsafe</p><blockquote><ul><li><p>Unsafe </p><p>(JDK里有unsafe对象，他可以直接拿到对象内存地址，基于内存地址可以进行一些读写操作)</p><p>如果是一个Unsafe类型的bytebuf, 可以直接拿到ByteBuf在 JVM里的具体的内存，可以直接调用jdk的unsafe进行读写。</p></li><li><p>非Unsafe 不会依赖到JDK底层unsafe的对象</p></li></ul></blockquote></li><li><p>Heap 和 Direct</p><blockquote><ul><li><p>Heap</p><p>直接在堆上进行内存分配，分配的内存受GC管理，不需要手动释放</p></li><li><p>Direct</p><p>直接调用JDK的API进行内存分配，不受JVM控制，所以最终不会参与GC过程，需要手动释放。</p></li></ul></blockquote></li></ul><h4 id="ByteBufAllocator-内存分配管理器"><a href="#ByteBufAllocator-内存分配管理器" class="headerlink" title="ByteBufAllocator 内存分配管理器"></a>ByteBufAllocator 内存分配管理器</h4><ul><li><p>AbstractByteBufAllocator </p><p>是实现了 ByteBufAllocator </p></li><li><p>两大子类  UnpooledByteBufAallocator/PooledByteBufAllocator</p><p><img src="/Users/guoyin/Library/Application Support/typora-user-images/image-20200223113955620.png" alt="image-20200223113955620"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ByteBuf&quot;&gt;&lt;a href=&quot;#ByteBuf&quot; class=&quot;headerlink&quot; title=&quot;ByteBuf&quot;&gt;&lt;/a&gt;ByteBuf&lt;/h2&gt;&lt;h4 id=&quot;常见问题&quot;&gt;&lt;a href=&quot;#常见问题&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="netty" scheme="http://yoursite.com/categories/netty/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>reactor guid</title>
    <link href="http://yoursite.com/wiki/reactor/reactor_3_guid_%E7%BF%BB%E8%AF%91%E4%B8%8D%E5%85%A8/"/>
    <id>http://yoursite.com/wiki/reactor/reactor_3_guid_翻译不全/</id>
    <published>2020-01-10T05:47:02.197Z</published>
    <updated>2020-04-22T11:47:58.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="About-the-Documentation"><a href="#About-the-Documentation" class="headerlink" title="About the Documentation"></a>About the Documentation</h1><p>本节简要概述了Reactor参考文档。不需要一行一行地阅读本指南，每一节都是独立的，尽管他们经常互相引用。</p><h1 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h1><h2 id="Introducing-Reactor"><a href="#Introducing-Reactor" class="headerlink" title="Introducing Reactor"></a>Introducing Reactor</h2><p>Reactor是JVM上的完全非阻塞的响应式编程框架，支持有效的需求管理（通过背压的方式）。它直接与Java 8的函数式API集成，特别是CompletableFuture、Stream和Duration。它提供了可组合的异步序列（asynchronous sequence）API：Flux（用于[N]个元素）和Mono（用于 [0|1]个元素）。广泛实现了<a href="https://www.reactive-streams.org/" target="_blank" rel="external nofollow noopener noreferrer">Reactive Streams</a>。<br>使用reactor-netty，Reactor也支持非阻塞的进程间通信。配合微服务架构，Reactor Netty为HTTP（包括Websockets）、TCP和UDP提供了背压的网络引擎。完全支持响应式的Encoding和Decoding。</p><h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><p>Reactor Core最低支持Java 8。<br>它依赖org.reactivestreams:reactive-streams:1.0.2。</p><p>Android支持：</p><ul><li>Reactor 3没有正式支持Android（RxJava 2支持）</li><li>在Android SDK 26以上可以工作得很好</li></ul><h1 id="Introduction-to-Reactive-Programming"><a href="#Introduction-to-Reactive-Programming" class="headerlink" title="Introduction to Reactive Programming"></a>Introduction to Reactive Programming</h1><p>Reactor是响应式编程范式的一个实现，可以概括为：<br>响应式编程是关于数据流和变化传播（the propagation of change）的异步编程范式。这意味着可以通过采用的编程语言轻松地表达静态（比如数组）或者动态（比如事件发送器）的数据流。<br>见<a href="https://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="external nofollow noopener noreferrer">Reactive_programming</a></p><p><a href="http://xn--microsoft-322o603cu08b.net/" target="_blank" rel="external nofollow noopener noreferrer">Microsoft最先在.NET</a> ecosystem增加了Reactive Extensions(Rx)库。然后，RxJava在JVM上实现了响应式编程。后来，通过Reactive Streams实现了Java上的标准化-Flow类定义的接口集和交互规则集成到了Java 9内。<br>响应式编程范式通常在面向对象的语言中出现，是Observer设计模式的扩展。比较一下响应式流和Iterator设计模式，一个主要不同点是，Iterator是pull-based的，而响应式流是push-based。<br>使用一个迭代器是一种命令式的编程模式，尽管访问值的方法完全是Iterable的责任。开发人员可以选择何时访问序列中的next()项。<br>而响应式流，是发布-订阅模式的。发布者提醒订阅者来了新值，这种push是响应式的关键。除了推送值，还以明确定义的方式，涵盖错误处理和完成。通过调用onNext，发布者将新值推送给订阅者。也可以通过调用onError发送一个错误信号，或者通过onComplete完成。错误和完成都会终止序列，可以概括为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onNext x 0..N [onError | onComplete]</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>这种方法非常灵活，它支持没有值、一个值和n个值（包括无限的值序列，比如时钟的连续滴答）。</p><p>但是，为什么需要一个异步的响应式库呢？</p><h2 id="Blocking-Can-Be-Wasteful"><a href="#Blocking-Can-Be-Wasteful" class="headerlink" title="Blocking Can Be Wasteful"></a>Blocking Can Be Wasteful</h2><p>现代程序可以覆盖大量并发用户，虽然硬件性能在持续提升，可软件性能还是一个关键问题。<br>有两种办法提高程序性能：</p><ul><li>parallelize：采用更多线程和更多硬件资源</li><li>seek more efficiency：寻求当前资源的更高效率</li></ul><p>一般来说，Java程序都是阻塞式的。容易达到性能瓶颈，就需要更多线程，运行类似的阻塞代码。这样做，很快就会出现争用和并发问题。<br>更糟糕的是，阻塞浪费资源。如果仔细观察，一旦程序涉及延迟（特别是I/O，比如数据库操作和网络调用），资源就会被浪费-因为线程处于空闲或者等待数据的状态。</p><h2 id="Asynchronicity-to-the-Rescue"><a href="#Asynchronicity-to-the-Rescue" class="headerlink" title="Asynchronicity to the Rescue?"></a>Asynchronicity to the Rescue?</h2><p>也可以编写异步的、非阻塞的代码，使用相同的底层资源切换到其他活动任务，等异步处理执行完成再切换回来。<br>在JVM内，怎么写异步代码呢？</p><ul><li>Callbacks：异步方法没有返回值，但是需要额外的回调参数（lambda或者匿名类），结果有效时就调用该参数。比如Swing中的EventListener</li><li>Futures：异步方法立即返回Future。异步过程计算T的值，Future对象包装了对值的访问。该值不会立即有效，值有效以后才可以拉取（poll）。比如运行Callable任务的ExecutorService使用Future对象</li></ul><p>这两种方法都有局限性。<br>Callbacks很难组合到一起。阅读和维护起来也很困难。</p><h2 id="From-Imperative-to-Reactive-Programming"><a href="#From-Imperative-to-Reactive-Programming" class="headerlink" title="From Imperative to Reactive Programming"></a>From Imperative to Reactive Programming</h2><p>诸如Reactor这样的响应式库不但解决上述缺点，还关注其他方面：</p><ul><li>组合性和可读性</li><li>数据作为流（flow），有丰富的operators</li><li>subscribe前什么都没发生</li><li>Backpressure，消费者向生产者发送明确的信号，表明生产得太快了</li><li>与并发无关的高级抽象</li></ul><h3 id="Composability-and-Readability"><a href="#Composability-and-Readability" class="headerlink" title="Composability and Readability"></a>Composability and Readability</h3><p>composability是指有能力编排多个异步任务，前一个任务的结果就是后续任务的输入，或者使用fork-join执行几个任务，也可以重用任务，把它作为更高级系统的组件。<br>编排任务的能力与代码的可读性和可维护性紧密相关。随着异步过程层级的数量和复杂性的增加，编写和阅读代码都变得越来越难。正如我们所看到的，回调很简单，但它的一个主要缺点是，对于复杂的过程，你需要在回调中执行回调，他们嵌套在一起（Callback Hell）。<br>Reactor提供了丰富的组合选项，代码反应了抽象过程的组织，全都位于同一级（嵌套最小化）。</p><h3 id="The-Assembly-Line-Analogy"><a href="#The-Assembly-Line-Analogy" class="headerlink" title="The Assembly Line Analogy"></a>The Assembly Line Analogy</h3><p>你可以想象为，响应式程序里的数据在装配线上移动。Reactor既是传送带，又是工作站。原材料从源注入（Publisher），最终的成品推送给消费者（Subscriber）。<br>原材料经历各种转换和其他中间步骤，或者是大型装配线上的一部分和其他部件聚合到一起。如果在某一点出现了故障或者堵塞（也许花费了太长时间），受影响的工作站可以向上游信号以限制原材料的流动。</p><h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h3><p>Reactor中，operators就是装配线类比中的工作站。每个operator都会向Publisher添加行为，并把前一步的Publisher包装成新的实例。整个链就这样形成了，数据从第一个Publisher沿着链向后移动，由每个link转发。最终，Subscriber完成了该过程。记住，在Subscriber订阅Publisher前，什么都没发生。<br>Reactive Streams规范根本没有指定任何operators，Reactor的最佳附加值就是添加了丰富的operators。他们涉及很多方面，从简单的转换、过滤到复杂的编排和错误处理。</p><h3 id="Nothing-Happens-Until-You-subscribe"><a href="#Nothing-Happens-Until-You-subscribe" class="headerlink" title="Nothing Happens Until You subscribe()"></a>Nothing Happens Until You subscribe()</h3><p>Reactor中，当你写一个Publisher链，默认情况下，数据不会启动。你要增加一个异步处理的抽象描述（帮助重用和组合）。<br>通过订阅，把Publisher绑定到Subscriber，从而出发整个链中的数据流。在内部，Subscriber发送一个request信号，向上游传递，直到Publisher。</p><h3 id="Backpressure"><a href="#Backpressure" class="headerlink" title="Backpressure"></a>Backpressure</h3><p>backpressure也是通过向上游传递信号实现的，还是用装配线做类比，如果工作站处理得比上游慢就发送一个反馈信号。<br>Reactive Streams规范的定义非常接近类比：subscriber可以在unbounded模式工作，让源以最快的速度推送数据;或者使用request机制，向源发信号，它现在可以处理最多n条数据。<br>中间operators也可以改变request。比如buffer operator，可以把数据分组。还有些operators实现了prefetching策略，这就避免了request(1)往返，如果在请求之前就生成元素不太昂贵，这样处理是划算的。<br>这样，把push模式变成了push-pull，如果有数据，下游可以从上游pull数据。如果没有数据，就等数据准备好以后push给下游。</p><h3 id="Hot-vs-Cold"><a href="#Hot-vs-Cold" class="headerlink" title="Hot vs Cold"></a>Hot vs Cold</h3><p>有两大类反应式序列hot和cold。主要区别是响应式流如何应答订阅：</p><ul><li>Cold：为每个Subscriber都生成新的序列，包括数据源。比如，如果源包装了一个HTTP调用，就为每个订阅生成一个新的HTTP请求</li><li>Hot：对于每个Subscriber，不会重新开始。相反，迟到的订阅者只能接收到订阅之后发射的数据。注意，一些hot响应式流可以缓存或者重放历史（甚至全部历史）。hot的序列甚至可以在没有订阅者时也发射数据</li></ul><h1 id="Reactor-Core-Features"><a href="#Reactor-Core-Features" class="headerlink" title="Reactor Core Features"></a>Reactor Core Features</h1><p>Reactor提供了可组合的响应式类型，他们（Flux和Mono）实现了Publisher，还提供了丰富的operators。Flux代表0…N个元素，Mono代表(0…1)。<br>比如，HTTP请求只有一个响应，所以应该不会做count运算。所以，使用Mono代表一次HTTP请求的结果会更好。<br>改变最大基数的Operators会切换相关类型。比如，Flux才有count运算，但是它返回Mono。</p><h2 id="Flux-an-Asynchronous-Sequence-of-0-N-Items"><a href="#Flux-an-Asynchronous-Sequence-of-0-N-Items" class="headerlink" title="Flux, an Asynchronous Sequence of 0-N Items"></a>Flux, an Asynchronous Sequence of 0-N Items</h2><p><img src="https://img-blog.csdnimg.cn/20190424153103201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM2NDE3Mg==,size_16,color_FFFFFF,t_70" alt="Flux"></p><p>Flux是一个标准的Publisher，可以由一个completion信号或者error终止。三种类型的信号转换为对下游Subscriber的onNext、onComplete或者onError方法的调用。<br>所有的事件，包括terminating，都是可选的。如果没有onNext事件但是有onComplete代表一个empty有限序列;而删除了onComplete，就变成一个无限的空序列（没什么用，除非要测试cancellation）。<br>无限序列不一定是空的，比如，Flux.interval(Duration)生产的Flux就是无限的，根据时钟发出滴答声。</p><h2 id="Mono-an-Asynchronous-0-1-Result"><a href="#Mono-an-Asynchronous-0-1-Result" class="headerlink" title="Mono, an Asynchronous 0-1 Result"></a>Mono, an Asynchronous 0-1 Result</h2><p><img src="https://img-blog.csdnimg.cn/20190424153123756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM2NDE3Mg==,size_16,color_FFFFFF,t_70" alt="Mono"></p><p>Mono 是一个专用的Publisher，最多发送一条数据，然后可以由onComplete或者onError信号终止。<br>只包含Flux的operators的子集，一些operators可以切换到Flux。<br>比如，Mono#concatWith(Publisher)返回一个Flux，Mono#then(Mono) 返回另一个Mono。<br>Mono可以代表一个无值的异步处理，它仅有completion概念（类似Runnable）。想增加这样一个，请使用Mono。</p><h2 id="Simple-Ways-to-Create-a-Flux-or-Mono-and-Subscribe-to-It"><a href="#Simple-Ways-to-Create-a-Flux-or-Mono-and-Subscribe-to-It" class="headerlink" title="Simple Ways to Create a Flux or Mono and Subscribe to It"></a>Simple Ways to Create a Flux or Mono and Subscribe to It</h2><p>可以使用工厂方法开始使用Flux和Mono。<br>比如，要增加一个String序列，可以枚举他们，可以放进集合，然后增加Flux：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; seq1 = Flux.just(<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"foobar"</span>);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; iterable = Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"foobar"</span>);</span><br><span class="line">Flux&lt;String&gt; seq2 = Flux.fromIterable(iterable);</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p>其他例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有值，也可以使用泛型</span></span><br><span class="line">Mono&lt;String&gt; noData = Mono.empty(); </span><br><span class="line"></span><br><span class="line">Mono&lt;String&gt; data = Mono.just(<span class="string">"foo"</span>);</span><br><span class="line"><span class="comment">//第一个参数是范围的开始，第二个参数是数量</span></span><br><span class="line">Flux&lt;Integer&gt; numbersFromFiveToSeven = Flux.range(<span class="number">5</span>, <span class="number">3</span>); </span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>订阅的时候，Flux和Mono支持Java 8 lambdas。可以选择.subscribe()的变种，将lambdas用于不同的回调组合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//订阅，触发一个序列</span></span><br><span class="line">subscribe(); </span><br><span class="line"><span class="comment">//使用每个产生的值做点啥</span></span><br><span class="line">subscribe(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer); </span><br><span class="line"><span class="comment">//处理值，也响应错误</span></span><br><span class="line">subscribe(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer,</span><br><span class="line">          Consumer&lt;? <span class="keyword">super</span> Throwable&gt; errorConsumer); </span><br><span class="line"><span class="comment">//处理值和错误。当序列successfully完成时，做点啥</span></span><br><span class="line">subscribe(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer,</span><br><span class="line">          Consumer&lt;? <span class="keyword">super</span> Throwable&gt; errorConsumer,</span><br><span class="line">          Runnable completeConsumer); </span><br><span class="line"><span class="comment">//处理值、错误和successful完成。再使用Subscription做点什么</span></span><br><span class="line">subscribe(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer,</span><br><span class="line">          Consumer&lt;? <span class="keyword">super</span> Throwable&gt; errorConsumer,</span><br><span class="line">          Runnable completeConsumer,</span><br><span class="line">          Consumer&lt;? <span class="keyword">super</span> Subscription&gt; subscriptionConsumer);</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure><p>这些变种返回对subscription的引用，当你不再需要数据时，可以cancel该subscription。通过cancellation，源会停止生产值，清除它增加的资源。这种cancel和清理由Disposable接口代表。</p><h3 id="subscribe-Method-Examples"><a href="#subscribe-Method-Examples" class="headerlink" title="subscribe Method Examples"></a>subscribe Method Examples</h3><p>本节包含subscribe方法的每个签名的最小示例。<br>先是无参方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产三个值</span></span><br><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//订阅</span></span><br><span class="line">ints.subscribe();</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p>前面的代码没有产生可见的输出，但是它能工作。该Flux产生了三个值。如果我们提供一个lambda，可以让值可视：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">3</span>); </span><br><span class="line"><span class="comment">//订阅，打印值</span></span><br><span class="line">ints.subscribe(i -&gt; System.out.println(i));</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>输出是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>为了演示下一个方法签名，我们故意引入错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产生四个值</span></span><br><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">4</span>) </span><br><span class="line"><span class="comment">//需要map处理不同的值</span></span><br><span class="line">      .map(i -&gt; &#123; </span><br><span class="line">          <span class="comment">//对于大多数值，返回该值</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">3</span>) <span class="keyword">return</span> i; </span><br><span class="line">        <span class="comment">//强制产生错误</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Got to 4"</span>); </span><br><span class="line">      &#125;);</span><br><span class="line"><span class="comment">//订阅包含了错误处理</span></span><br><span class="line">ints.subscribe(i -&gt; System.out.println(i), </span><br><span class="line">      error -&gt; System.err.println(<span class="string">"Error: "</span> + error));</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p>我们有两个lambda表达式，一个为期望的内容，一个为错误。输出是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">Error: java.lang.RuntimeException: Got to 4</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>subscribe的下一个签名包含completion事件的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">4</span>); </span><br><span class="line">ints.subscribe(i -&gt; System.out.println(i),</span><br><span class="line">    error -&gt; System.err.println(<span class="string">"Error "</span> + error),</span><br><span class="line">    () -&gt; System.out.println(<span class="string">"Done"</span>)); </span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p>error信号和completion信号都是终止事件，彼此排斥（不可能同时得到）。要使completion消费者工作，就不能触发错误。<br>completion回调没有输入，由一对空括号表示：它匹配Runnable接口的run方法。前面代码的输出是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">Done</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>subscribe方法的最后一个签名包含一个Consumer。可以使用Subscription做些事情：执行request(long)，或者cancel()。否则Flux会被挂起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">ints.subscribe(i -&gt; System.out.println(i),</span><br><span class="line">    error -&gt; System.err.println(<span class="string">"Error "</span> + error),</span><br><span class="line">    () -&gt; System.out.println(<span class="string">"Done"</span>),</span><br><span class="line">    <span class="comment">//源最多发射10个元素，实际上，只发射了四个</span></span><br><span class="line">    sub -&gt; sub.request(<span class="number">10</span>)); </span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="Cancelling-a-subscribe-with-its-Disposable"><a href="#Cancelling-a-subscribe-with-its-Disposable" class="headerlink" title="Cancelling a subscribe() with its Disposable"></a>Cancelling a subscribe() with its Disposable</h3><p>subscribe()的这些变种都有一个Disposable返回类型。在这里，Disposable代表订阅能被取消（通过调用dispose() 方法）。<br>对于Flux和Mono，cancellation是一个信号，源会停止产生数据。但是，不能保证是立竿见影的。有些源生产数据的速度太快，在收到cancel指令前可能已经完成了。<br>Disposables类中有一些实用的工具。Disposables.swap()增加一个Disposable包装器，允许你原子地cancel或者替换一个具体的Disposable。比如在一个UI场景中，每当用户按下一个button，你就可以cancel一个请求，替换成一个新的。</p><h3 id="Alternative-to-lambdas-BaseSubscriber"><a href="#Alternative-to-lambdas-BaseSubscriber" class="headerlink" title="Alternative to lambdas: BaseSubscriber"></a>Alternative to lambdas: BaseSubscriber</h3><p>也可以扩展BaseSubscriber，实现订阅功能。<br>比如这样调用一个SampleSubscriber：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SampleSubscriber&lt;Integer&gt; ss = <span class="keyword">new</span> SampleSubscriber&lt;Integer&gt;();</span><br><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">ints.subscribe(i -&gt; System.out.println(i),</span><br><span class="line">    error -&gt; System.err.println(<span class="string">"Error "</span> + error),</span><br><span class="line">    () -&gt; &#123;System.out.println(<span class="string">"Done"</span>);&#125;,</span><br><span class="line">    s -&gt; s.request(<span class="number">10</span>));</span><br><span class="line">ints.subscribe(ss);</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>SampleSubscriber是这样实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BaseSubscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hookOnSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Subscribed"</span>);</span><br><span class="line">request(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hookOnNext</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">System.out.println(value);</span><br><span class="line">request(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p>SampleSubscriber类扩展了BaseSubscriber，这是自定义Subscribers时，Reactor推荐扩展的抽象类。它提供了可以被覆盖的钩子，以调整subscriber的行为。默认会触发一个unbounded的请求，表现得很像subscribe()。如果你想自定义请求总量，扩展BaseSubscriber就很好。<br>要自定义请求量，最低限度要实现hookOnSubscribe(Subscription subscription) 和hookOnNext(T value)。前面的例子，hookOnSubscribe打印到标准输出，然后发送第一次请求。hookOnNext打印值，执行附加的请求，每次一条。<br>上面SampleSubscriber类的输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subscribed</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>BaseSubscriber类还包含requestUnbounded()方法，可以切换到unbounded模式（相当于request(Long.MAX_VALUE)）。此外还有cancel()方法。<br>它还有这些钩子：hookOnComplete、hookOnError、hookOnCancel和hookFinally（总是在序列终止时被调用，终止类型见SignalType参数）。</p><h3 id="On-Backpressure-and-ways-to-reshape-requests"><a href="#On-Backpressure-and-ways-to-reshape-requests" class="headerlink" title="On Backpressure, and ways to reshape requests"></a>On Backpressure, and ways to reshape requests</h3><p>Reactor实现背压的时候，消费者向上游operator发送request。当前请求的和有时候被称为当前demand或者是pending request。上限是Long.MAX_VALUE，代表无限的请求（没有背压）。<br>第一个请求来自最终的subscriber。在订阅的时候，最直接的办法是触发无限的请求：</p><ul><li>subscribe()和大多数变种</li><li>block()、blockFirst()和blockLast()</li><li>使用toIterable()/toStream()迭代</li></ul><p>自定义原始请求的最简单的办法是覆盖BaseSubscriber的hookOnSubscribe方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">    .doOnRequest(r -&gt; System.out.println(<span class="string">"request of "</span> + r))</span><br><span class="line">    .subscribe(<span class="keyword">new</span> BaseSubscriber&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hookOnSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">        request(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hookOnNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cancelling after having received "</span> + integer);</span><br><span class="line">        cancel();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><p>输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request of 1</span><br><span class="line">Cancelling after having received 1</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>操纵request的时候，你必须小心地产生足够的序列要求，否则你的Flux会被卡住。所以，BaseSubscriber的hookOnSubscribe默认是无限的request。如果你覆盖这个钩子，最少要调用一次request。</p><h4 id="Operators-changing-the-demand-from-downstream"><a href="#Operators-changing-the-demand-from-downstream" class="headerlink" title="Operators changing the demand from downstream"></a>Operators changing the demand from downstream</h4><p>要记住，subscribe级别的要求，能被上游的每个operator重新整形。比如buffer(N) operator：如果它收到request(2)，它解释成需要two full buffers。因为buffers认为有N个元素就是满的，该buffer operator使得request成了2 x N。</p><p>Prefetch是在内部序列调整初始request的方法，一般来说，默认是32。<br>这些operators一般也实现了补充（replenishing）优化：一旦operator看到25%的prefetch已经完成，就再向上游请求25%。这是一种启发式的优化，让这些operators主动预测即将到来的请求。</p><p>也可以直接调整request：limitRate和limitRequest。<br>limitRate(N)拆分下游请求，让他们以较小的批量传播到上游。比如一个100的request，通过limitRate(10)会导致最多10次10个的requests，传播到上游。limitRate实现了上面讨论的补充优化。<br>该operator有个变种，可以调整补充总量：limitRate(highTide, lowTide)，lowTide为0就是严格的highTide批量的请求，而没有补充优化。<br>limitRequest(N)定义下游request的最大总需求。如果单个request不会让总需求超过N，整个request就会传给上游。达到总量，limitRequest认为序列完成，向下游发射onComplete并cancel资源。</p><h1 id="Reactor-Core-Features-1"><a href="#Reactor-Core-Features-1" class="headerlink" title="Reactor Core Features"></a>Reactor Core Features</h1><h2 id="Programmatically-creating-a-sequence"><a href="#Programmatically-creating-a-sequence" class="headerlink" title="Programmatically creating a sequence"></a>Programmatically creating a sequence</h2><p>本节介绍如何程序化增加Flux和Mono，以及相关事件（onNext、onError和onComplete）。这些方法都触发了称为sink的事件。实际上是sink的变种。</p><h3 id="Synchronous-generate"><a href="#Synchronous-generate" class="headerlink" title="Synchronous generate"></a>Synchronous generate</h3><p>程序化增加Flux的最简单办法是generate方法，接受一个generator 函数。它是同步的，one-by-one 地发射。这是一个SynchronousSink，每次回调最多只能调用一次next()方法。之后可以调用error(Throwable)和complete(),他们是可选的。<br>最有用的变种可能是：让你保持state，还可以引用sink，决定下一个发射什么。该generator函数变成了BiFunction&lt;S, SynchronousSink&lt; T &gt;, S&gt;，其中&lt; S &gt;就是state对象。你可以为初始state提供一个Supplier&lt; S &gt;，你的generator 函数在每一轮都能返回一个新state。<br>比如，使用int做state：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux = Flux.generate(</span><br><span class="line">        <span class="comment">//初始state是0</span></span><br><span class="line">    () -&gt; <span class="number">0</span>, </span><br><span class="line">    (state, sink) -&gt; &#123;</span><br><span class="line">        <span class="comment">//根据state选择发射的内容</span></span><br><span class="line">      sink.next(<span class="string">"3 x "</span> + state + <span class="string">" = "</span> + <span class="number">3</span>*state); </span><br><span class="line">      <span class="comment">//完成</span></span><br><span class="line">      <span class="keyword">if</span> (state == <span class="number">10</span>) sink.complete(); </span><br><span class="line">      <span class="comment">//新的state</span></span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span>; </span><br><span class="line">    &#125;);</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><p>上面代码的输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">3 x 0 &#x3D; 0</span><br><span class="line">3 x 1 &#x3D; 3</span><br><span class="line">3 x 2 &#x3D; 6</span><br><span class="line">3 x 3 &#x3D; 9</span><br><span class="line">3 x 4 &#x3D; 12</span><br><span class="line">3 x 5 &#x3D; 15</span><br><span class="line">3 x 6 &#x3D; 18</span><br><span class="line">3 x 7 &#x3D; 21</span><br><span class="line">3 x 8 &#x3D; 24</span><br><span class="line">3 x 9 &#x3D; 27</span><br><span class="line">3 x 10 &#x3D; 30</span><br><span class="line">1234567891011</span><br></pre></td></tr></table></figure><p>也可以使用可变的。比如下面的代码，使用AtomicLong做state：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux = Flux.generate(</span><br><span class="line">        <span class="comment">//state可变</span></span><br><span class="line">    AtomicLong::<span class="keyword">new</span>, </span><br><span class="line">    (state, sink) -&gt; &#123;</span><br><span class="line">        <span class="comment">//改变了state</span></span><br><span class="line">      <span class="keyword">long</span> i = state.getAndIncrement(); </span><br><span class="line">      sink.next(<span class="string">"3 x "</span> + i + <span class="string">" = "</span> + <span class="number">3</span>*i);</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">10</span>) sink.complete();</span><br><span class="line">      返回新state的同一个实例</span><br><span class="line">      <span class="keyword">return</span> state; </span><br><span class="line">    &#125;);</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><p>如果state需要清理资源。可以使用generate(Supplier, BiFunction, Consumer)清理最后一个state实例。<br>下面的例子就包含了一个Consumer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux = Flux.generate(</span><br><span class="line">    AtomicLong::<span class="keyword">new</span>,</span><br><span class="line">      (state, sink) -&gt; &#123; </span><br><span class="line">      <span class="keyword">long</span> i = state.getAndIncrement(); </span><br><span class="line">      sink.next(<span class="string">"3 x "</span> + i + <span class="string">" = "</span> + <span class="number">3</span>*i);</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">10</span>) sink.complete();</span><br><span class="line">      <span class="keyword">return</span> state; </span><br><span class="line">      <span class="comment">//最后输出11</span></span><br><span class="line">    &#125;, (state) -&gt; System.out.println(<span class="string">"state: "</span> + state)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><p>如果该state包含数据库连接，或者其他需要处理的资源。该Consumer表达式可以关闭连接或者其他处理。</p><h3 id="Asynchronous-amp-multi-threaded-create"><a href="#Asynchronous-amp-multi-threaded-create" class="headerlink" title="Asynchronous &amp; multi-threaded: create"></a>Asynchronous &amp; multi-threaded: create</h3><p>create比较先进，支持每轮多个发射，甚至支持多线程。<br>它暴露了一个FluxSink，有next、error和complete方法。和generate不同，它没有基于state的变种。在回调中，能触发多线程事件。<br>create可以把现有API带入响应式世界，比如基于监听器的异步API。<br>create不会并行化你的代码，也不会把代码变成异步的。即使使用subscribeOn，也要注意：长时间阻塞create lambda（比如无限循环地调用sink.next(t)）会锁定管道。请求可能永远不会被执行。使用subscribeOn(Scheduler, false) 变种，requestOnSeparateThread = false，create使用Scheduler线程，数据流执行请求也使用同样的线程。</p><p>想像你使用listener-based API。它通过chunks处理事件，有两个事件：(1) 数据准备好，(2) 处理完成（terminal事件）。如MyEventListener接口所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyEventListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDataChunk</span><span class="params">(List&lt;T&gt; chunk)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p>你可以create一个bridge，放进Flux：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; &#123;</span><br><span class="line">    <span class="comment">//每当myEventProcessor执行时，他们异步执行</span></span><br><span class="line">    myEventProcessor.register( </span><br><span class="line">      <span class="keyword">new</span> MyEventListener&lt;String&gt;() &#123; </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataChunk</span><span class="params">(List&lt;String&gt; chunk)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(String s : chunk) &#123;</span><br><span class="line">              <span class="comment">//chunk中的每个元素，成为Flux中的元素</span></span><br><span class="line">            sink.next(s); </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//processComplete事件转换成onComplete</span></span><br><span class="line">            sink.complete(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure><p>另外，因为create能bridge异步API，管理背压，你可以通过OverflowStrategy，来优化背压：</p><ul><li>IGNORE：完全忽略下游的背压请求。当下游队列满时，可能产生IllegalStateException</li><li>ERROR：下游跟不上时，IllegalStateException</li><li>DROP：下游没准备好接收，就抛弃输入信号</li><li>LATEST：下游只读取最新信号</li><li>BUFFER（默认）：下游忙不过来就缓冲信号（无限的buffer，可能导致OutOfMemoryError）</li></ul><p>Mono也有create generator。MonoSink不允许多个发射。在第一个之后drop全部信号。</p><h3 id="Asynchronous-but-single-threaded-push"><a href="#Asynchronous-but-single-threaded-push" class="headerlink" title="Asynchronous but single-threaded: push"></a>Asynchronous but single-threaded: push</h3><p>push位于generate和create之间，适合处理单个生产者的事件。和create类似，它支持异步，也可以像create那样管理背压。但是，在某一时刻，只能有一个生产者线程调用next、complete和error。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; bridge = Flux.push(sink -&gt; &#123;</span><br><span class="line">    myEventProcessor.register(</span><br><span class="line">      <span class="keyword">new</span> SingleThreadEventListener&lt;String&gt;() &#123; </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataChunk</span><span class="params">(List&lt;String&gt; chunk)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(String s : chunk) &#123;</span><br><span class="line">              /使用next，从单个监听器线程推送数据给sink</span><br><span class="line">            sink.next(s); </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//complete事件由同一个监听器线程生成</span></span><br><span class="line">            sink.complete(); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//error事件也由同一个监听器线程生成</span></span><br><span class="line">            sink.error(e); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure><h4 id="An-hybrid-push-pull-model"><a href="#An-hybrid-push-pull-model" class="headerlink" title="An hybrid push/pull model"></a>An hybrid push/pull model</h4><p>大多数Reactor operators，比如create，遵循混合push/pull 模式。尽管大部分处理是异步的（建议使用push方式），但是也有pull组件-request。<br>消费者从源pulls数据，在第一次请求之前不会发射任何数据。然后，只要数据准备好，源就把数据推给消费者，不过要在请求总量范围内。push() 和create()都允许设置一个onRequest消费者，以便管理请求总量、并确保只有在他们等候请求的时候才通过sink推送数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; &#123;</span><br><span class="line">    myMessageProcessor.register(</span><br><span class="line">      <span class="keyword">new</span> MyMessageListener&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(List&lt;String&gt; messages)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(String s : messages) &#123;</span><br><span class="line">              <span class="comment">//之后异步到达的其余消息也被交付</span></span><br><span class="line">            sink.next(s); </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    sink.onRequest(n -&gt; &#123;</span><br><span class="line">        <span class="comment">//请求之后拉消息</span></span><br><span class="line">        List&lt;String&gt; messages = myMessageProcessor.getHistory(n); </span><br><span class="line">        <span class="keyword">for</span>(String s : message) &#123;</span><br><span class="line">            <span class="comment">//如果消息有效，就推给sink</span></span><br><span class="line">           sink.next(s); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure><h4 id="Cleaning-up-after-push-or-create"><a href="#Cleaning-up-after-push-or-create" class="headerlink" title="Cleaning up after push() or create()"></a>Cleaning up after push() or create()</h4><p>两个回调，onDispose和onCancel，在终止或者取消的时候执行清理。onDispose在Flux完成、错误退出或者取消后执行。onCancel在onDispose执行之前执行任何取消动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; &#123;</span><br><span class="line">    sink.onRequest(n -&gt; channel.poll(n))</span><br><span class="line">    <span class="comment">//onCancel先被调用，仅适用cancel信号</span></span><br><span class="line">        .onCancel(() -&gt; channel.cancel())</span><br><span class="line">        <span class="comment">//onDispose被调用，适用complete、error或者cancel信号 </span></span><br><span class="line">        .onDispose(() -&gt; channel.close())  </span><br><span class="line">    &#125;);</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><h3 id="Handle"><a href="#Handle" class="headerlink" title="Handle"></a>Handle</h3><p>handle方法有很大的不同。它是一个实例方法，它是链式的只能在已经存在的源上。支持Mono和Flux。<br>它接近generate，从某种意义上说，它使用了SynchronousSink，只能一个接一个地发射。不过，handle可以从每个源生成任意值，可能会跳过一些元素。可以当作map和filter的组合。它的签名是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Flux&lt;R&gt; <span class="title">handle</span><span class="params">(BiConsumer&lt;T, SynchronousSink&lt;R&gt;&gt;)</span></span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>下来看一个例子，响应式流规范里序列不能有null值。如果你想执行一个map，但是你想使用已经存在的方法做map操作，该方法有时候返回null。<br>比如下面的方法可以安全地用于整数源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">alphabet</span><span class="params">(<span class="keyword">int</span> letterNumber)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (letterNumber &lt; <span class="number">1</span> || letterNumber &gt; <span class="number">26</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> letterIndexAscii = <span class="string">'A'</span> + letterNumber - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span> + (<span class="keyword">char</span>) letterIndexAscii;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>我们可以使用handle删除任何null：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; alphabet = Flux.just(-<span class="number">1</span>, <span class="number">30</span>, <span class="number">13</span>, <span class="number">9</span>, <span class="number">20</span>)</span><br><span class="line">    .handle((i, sink) -&gt; &#123;</span><br><span class="line">        <span class="comment">//映射成字符串</span></span><br><span class="line">        String letter = alphabet(i); </span><br><span class="line">        <span class="keyword">if</span> (letter != <span class="keyword">null</span>) </span><br><span class="line">            <span class="comment">//如果返回null，不调用sink.next</span></span><br><span class="line">            sink.next(letter); </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">alphabet.subscribe(System.out::println);</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><p>程序的输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M</span><br><span class="line">I</span><br><span class="line">T</span><br><span class="line">123</span><br></pre></td></tr></table></figure><h2 id="Threading-and-Schedulers"><a href="#Threading-and-Schedulers" class="headerlink" title="Threading and Schedulers"></a>Threading and Schedulers</h2><p>Reactor是并发不可知论者（concurrency agnostic），它不会强制并发模型。<br>获取Flux或者Mono不意味着它在专用的线程中运行。大多数operators 会在前一个operator工作的线程中执行。如果不指定，源在subscribe() 调用的线程中运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Mono&lt;String&gt;在main线程中组装</span></span><br><span class="line">  <span class="keyword">final</span> Mono&lt;String&gt; mono = Mono.just(<span class="string">"hello "</span>); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; mono</span><br><span class="line">      .map(msg -&gt; msg + <span class="string">"thread "</span>)</span><br><span class="line">      .subscribe(v -&gt; </span><br><span class="line">      <span class="comment">//在Thread-0订阅，于是，map和onNext回调也在该线程中执行</span></span><br><span class="line">          System.out.println(v + Thread.currentThread().getName()) </span><br><span class="line">      )</span><br><span class="line">  ).join();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure><p>程序的输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello thread Thread-0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>Reactor中，执行模型和在哪儿执行由使用的Scheduler决定。Scheduler的调度职责类似于ExecutorService，不过作为时钟，做了更多。<br>Schedulers类的静态方法可以访问执行上下文：</p><ul><li>immediate() - 当前线程</li><li>single() - 单个、可重用线程。注意，该方法会为所有调用者重用同一个线程，知道它被disposed。如果你想为每个调用生成专有的线程，使用newSingle()方法</li><li>elastic() - 一个弹性线程池。按需增加工作线程池，重用空闲的。线程持续空闲太久（默认60秒），会被disposed。I/O阻塞工作可以使用该方法</li><li>parallel() - 固定大小的线程池：CPU核数</li></ul><p>也可以使用Schedulers.fromExecutorService(ExecutorService)方法，从已经存在的ExecutorService增加Scheduler。（也可以从Executor增加）<br>如果阻塞无法避免，可以使用elastic帮助遗留的阻塞代码，single和parallel不行。所以，如果在默认的single和parallel的Schedulers内使用Reactor的阻塞API（block()、blockFirst()和blockLast()，还有迭代的toIterable()和toStream()），会抛IllegalStateException。<br>通过创建实现了NonBlocking标记接口的Thread的实例，也能自定义“仅非阻塞”的Schedulers。</p><p>一些operators默认使用特定的Scheduler（你也可以使用不同的）。比如，Flux.interval(Duration.ofMillis(300)) 产生的Flux，默认使用Schedulers.parallel()。你也可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用不同的Scheduler</span></span><br><span class="line">Flux.interval(Duration.ofMillis(<span class="number">300</span>), Schedulers.newSingle(<span class="string">"test"</span>))</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p>Reactor提供了两种在响应式链中切换执行上下文（Scheduler）的方法：publishOn和subscribeOn。都接受Scheduler参数，来切换上下文。但是，在链中publishOn的位置很重要，而subscribeOn的位置却不重要。<br>当你链式operators的时候，可以包装很多Flux和Mono。一旦你subscribe了，Subscriber对象的链就生成了，一直回到源。当然你看不到，你能看到的外层的Flux（Mono）和Subscription，但是，实际工作发生在这些中间operator的订阅者那里。<br>有了这些知识，我们仔细看看publishOn和subscribeOn：</p><h3 id="publishOn"><a href="#publishOn" class="headerlink" title="publishOn"></a>publishOn</h3><p>publishOn跟其他operator一样，在订阅链的中间。从上游接收信号，下游的operators在相关Scheduler的线程上执行。</p><ul><li>从Scheduler选择线程，改变执行上下文</li><li>onNext使用同一个线程，按顺序执行</li><li>或者在特定的Scheduler上工作，或者publishOn之后的operators在相同线程上执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新Scheduler，包含4个线程</span></span><br><span class="line">Scheduler s = Schedulers.newParallel(<span class="string">"parallel-scheduler"</span>, <span class="number">4</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Flux&lt;String&gt; flux = Flux</span><br><span class="line">    .range(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">//第一个map在匿名线程上执行</span></span><br><span class="line">    .map(i -&gt; <span class="number">10</span> + i)  </span><br><span class="line">    <span class="comment">//切换到s包含的线程</span></span><br><span class="line">    .publishOn(s)  </span><br><span class="line">    <span class="comment">//第二个map在s的线程上执行</span></span><br><span class="line">    .map(i -&gt; <span class="string">"value "</span> + i);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅使用了这个匿名线程。print发生在s包含的线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; flux.subscribe(System.out::println));</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><h3 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn"></a>subscribeOn</h3><p>当构造后向的链时，subscribeOn用于subscription处理。不管你在链的任何位置写subscribeOn，它都影响源的上下文。它不影响调用了publishOn的子序列的上下文。</p><ul><li>改变订阅之上整个链的operators的线程</li><li>从Scheduler挑一个线程</li></ul><p>链中最早的subscribeOn有效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新Scheduler，包含4个线程</span></span><br><span class="line">Scheduler s = Schedulers.newParallel(<span class="string">"parallel-scheduler"</span>, <span class="number">4</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Flux&lt;String&gt; flux = Flux</span><br><span class="line">    .range(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">//第一个map在s的线程上执行</span></span><br><span class="line">    .map(i -&gt; <span class="number">10</span> + i)  </span><br><span class="line">    <span class="comment">//因为subscribeOn，从订阅开始切换序列</span></span><br><span class="line">    .subscribeOn(s)  </span><br><span class="line">    <span class="comment">//和第一个map的执行线程相同</span></span><br><span class="line">    .map(i -&gt; <span class="string">"value "</span> + i);  </span><br><span class="line"><span class="comment">//订阅初始化时使用匿名线程。然后马上切换到s的线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; flux.subscribe(System.out::println)); </span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure><h2 id="Handling-Errors"><a href="#Handling-Errors" class="headerlink" title="Handling Errors"></a>Handling Errors</h2><p>响应式系统中，错误是结束事件。当错误发生的时候，它停止序列，传播到链的最后一步，定义的Subscriber的onError方法。<br>此类错误应该由程序处理。比如，显示错误提示，或者发送有意义的错误信息。因此，应该定义onError方法。<br>如果没定义，抛出UnsupportedOperationException。你可以做进一步检测，使用Exceptions.isErrorCallbackNotImplemented方法分流。</p><p>Reactor也支持在链的中间处理错误，这就是错误operators。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">//i等于0时抛异常</span></span><br><span class="line">    .map(i -&gt; <span class="string">"100 / "</span> + i + <span class="string">" = "</span> + (<span class="number">100</span> / i)) </span><br><span class="line">    <span class="comment">//错误处理</span></span><br><span class="line">    .onErrorReturn(<span class="string">"Divided by zero :("</span>); </span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>在你学习错误处理operators前，必须记住，错误是序列的结束事件。甚至你使用了错误处理operator，也不会允许原始（original）序列继续。onError信号会作为新序列的开头（回退）</p><h3 id="Error-Handling-Operators"><a href="#Error-Handling-Operators" class="headerlink" title="Error Handling Operators"></a>Error Handling Operators</h3><p>你可能熟悉使用try-catch处理异常：</p><ul><li>Catch，返回静态默认值</li><li>Catch，使用回退（fallback）方法执行其他路径</li><li>Catch，动态计算fallback值</li><li>Catch，包装成一个BusinessException，重新抛出</li><li>Catch，记录错误信息，重新抛出</li><li>使用finally块或者try-with-resource清理资源</li></ul><p>所有的这些，在Reactor中都有等价物，有对应的错误处理operators。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; s = Flux.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//会泡异常</span></span><br><span class="line">    .map(v -&gt; doSomethingDangerous(v))</span><br><span class="line">    <span class="comment">//如果一切正常，会执行 </span></span><br><span class="line">    .map(v -&gt; doSecondTransform(v));</span><br><span class="line">s.subscribe(value -&gt; System.out.println(<span class="string">"RECEIVED "</span> + value), <span class="comment">//如果没失败，成功打印</span></span><br><span class="line">            error -&gt; System.err.println(<span class="string">"CAUGHT "</span> + error) <span class="comment">//如果有错误，序列种植，打印失败信息</span></span><br><span class="line">);</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><p>和下面的代码类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//如果错误就抛异常</span></span><br><span class="line">        String v1 = doSomethingDangerous(i);</span><br><span class="line">        <span class="comment">//正确就执行</span></span><br><span class="line">        String v2 = doSecondTransform(v1); </span><br><span class="line">        System.out.println(<span class="string">"RECEIVED "</span> + v2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="comment">//异常就跳转到这里</span></span><br><span class="line">    System.err.println(<span class="string">"CAUGHT "</span> + t); </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><h4 id="Static-Fallback-Value"><a href="#Static-Fallback-Value" class="headerlink" title="Static Fallback Value"></a>Static Fallback Value</h4><p>返回静态默认值，相当于onErrorReturn：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingDangerous(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable error) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"RECOVERED"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">10</span>)</span><br><span class="line">    .map(<span class="keyword">this</span>::doSomethingDangerous)</span><br><span class="line">    .onErrorReturn(<span class="string">"RECOVERED"</span>);</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>也可以使用任选的Predicate：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">10</span>)</span><br><span class="line">    .map(<span class="keyword">this</span>::doSomethingDangerous)</span><br><span class="line">    <span class="comment">//只有在异常消息是boom10的时候，才返回</span></span><br><span class="line">    .onErrorReturn(e -&gt; e.getMessage().equals(<span class="string">"boom10"</span>), <span class="string">"recovered10"</span>); </span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><h4 id="Fallback-Method"><a href="#Fallback-Method" class="headerlink" title="Fallback Method"></a>Fallback Method</h4><p>如果不想简单返回默认值，而是有其他的处理数据的路径，可以使用onErrorResume：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String v1;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  v1 = callExternalService(<span class="string">"key1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable error) &#123;</span><br><span class="line">  v1 = getFromCache(<span class="string">"key1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String v2;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  v2 = callExternalService(<span class="string">"key2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable error) &#123;</span><br><span class="line">  v2 = getFromCache(<span class="string">"key2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><p>变成了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"key1"</span>, <span class="string">"key2"</span>)</span><br><span class="line"><span class="comment">//对于每个key，异步调用外部服务</span></span><br><span class="line">    .flatMap(k -&gt; callExternalService(k)</span><br><span class="line">    <span class="comment">//如果调用失败，返回缓存值 </span></span><br><span class="line">        .onErrorResume(e -&gt; getFromCache(k)) </span><br><span class="line">    );</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>onErrorResume也有Predicate变种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"timeout1"</span>, <span class="string">"unknown"</span>, <span class="string">"key2"</span>)</span><br><span class="line">    .flatMap(k -&gt; callExternalService(k)</span><br><span class="line">        .onErrorResume(error -&gt; &#123; <span class="comment">//动态选择</span></span><br><span class="line">            <span class="keyword">if</span> (error <span class="keyword">instanceof</span> TimeoutException) <span class="comment">//超时</span></span><br><span class="line">                <span class="keyword">return</span> getFromCache(k);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (error <span class="keyword">instanceof</span> UnknownKeyException)  <span class="comment">//不知道的key</span></span><br><span class="line">                <span class="keyword">return</span> registerNewEntry(k, <span class="string">"DEFAULT"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> Flux.error(error); <span class="comment">//重新抛出异常</span></span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><h4 id="Dynamic-Fallback-Value"><a href="#Dynamic-Fallback-Value" class="headerlink" title="Dynamic Fallback Value"></a>Dynamic Fallback Value</h4><p>也可以根据异常，计算fallback值。<br>比如，你返回的MyWrapper类型，专门有一个保存了异常的变种（想一下Future.complete(T success)和Future.completeExceptionally(Throwable error)）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Value v = erroringMethod();</span><br><span class="line">  <span class="keyword">return</span> MyWrapper.fromValue(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable error) &#123;</span><br><span class="line">  <span class="keyword">return</span> MyWrapper.fromError(error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>如果使用onErrorResume，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">erroringFlux.onErrorResume(error -&gt; Mono.just( </span><br><span class="line">        <span class="comment">//需要计算异常中的值</span></span><br><span class="line">        MyWrapper.fromError(error) </span><br><span class="line">));</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><h4 id="Catch-and-Rethrow"><a href="#Catch-and-Rethrow" class="headerlink" title="Catch and Rethrow"></a>Catch and Rethrow</h4><p>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> callExternalService(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable error) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">"oops, SLA exceeded"</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>可以写成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"timeout1"</span>)</span><br><span class="line">    .flatMap(k -&gt; callExternalService(k))</span><br><span class="line">    .onErrorResume(original -&gt; Flux.error(</span><br><span class="line">            <span class="keyword">new</span> BusinessException(<span class="string">"oops, SLA exceeded"</span>, original))</span><br><span class="line">    );</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>也可以这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"timeout1"</span>)</span><br><span class="line">    .flatMap(k -&gt; callExternalService(k))</span><br><span class="line">    .onErrorMap(original -&gt; <span class="keyword">new</span> BusinessException(<span class="string">"oops, SLA exceeded"</span>, original));</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><h4 id="Log-or-React-on-the-Side"><a href="#Log-or-React-on-the-Side" class="headerlink" title="Log or React on the Side"></a>Log or React on the Side</h4><p>如果你希望错误继续传播，不修改序列，只是记录它，可以使用doOnError。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> callExternalService(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException error) &#123;</span><br><span class="line">  <span class="comment">//记录日志</span></span><br><span class="line">  log(<span class="string">"uh oh, falling back, service failed for key "</span> + k);</span><br><span class="line">  <span class="keyword">throw</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><p>该doOnError，和前面的其他以doOn为前缀的operators一样，有时候被称为“副作用”。可以用来在不修改序列事件的情况下查看他们。<br>下面的例子还会传播错误，但是我们记录下来了。我们甚至使用了错误统计计数器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LongAdder failureStat = <span class="keyword">new</span> LongAdder();</span><br><span class="line">Flux&lt;String&gt; flux =</span><br><span class="line">Flux.just(<span class="string">"unknown"</span>)</span><br><span class="line">    .flatMap(k -&gt; callExternalService(k) <span class="comment">//调用失败</span></span><br><span class="line">        .doOnError(e -&gt; &#123;</span><br><span class="line">            failureStat.increment();</span><br><span class="line">            log(<span class="string">"uh oh, falling back, service failed for key "</span> + k); <span class="comment">//日志+统计</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//仍然会因为错误而终止，除非我们在这里使用error-recovery operator</span></span><br><span class="line">    );</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><h4 id="Using-Resources-and-the-Finally-Block"><a href="#Using-Resources-and-the-Finally-Block" class="headerlink" title="Using Resources and the Finally Block"></a>Using Resources and the Finally Block</h4><p>对于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stats stats = <span class="keyword">new</span> Stats();</span><br><span class="line">stats.startTimer();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  doSomethingDangerous();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  stats.stopTimerAndRecordTiming();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (SomeAutoCloseable disposableInstance = <span class="keyword">new</span> SomeAutoCloseable()) &#123;</span><br><span class="line">  <span class="keyword">return</span> disposableInstance.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>分别对应doFinally和using。</p><p>不管序列终止（onComplete、onError）或者被取消，都会执行doFinally。你可以知道结束类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Stats stats = <span class="keyword">new</span> Stats();</span><br><span class="line">LongAdder statsCancel = <span class="keyword">new</span> LongAdder();</span><br><span class="line"></span><br><span class="line">Flux&lt;String&gt; flux =</span><br><span class="line">Flux.just(<span class="string">"foo"</span>, <span class="string">"bar"</span>)</span><br><span class="line">    .doOnSubscribe(s -&gt; stats.startTimer())</span><br><span class="line">    .doFinally(type -&gt; &#123; <span class="comment">//结束类型SignalType</span></span><br><span class="line">        stats.stopTimerAndRecordTiming();</span><br><span class="line">        <span class="keyword">if</span> (type == SignalType.CANCEL) <span class="comment">//如果是取消，就统计</span></span><br><span class="line">          statsCancel.increment();</span><br><span class="line">    &#125;)</span><br><span class="line">    .take(<span class="number">1</span>);<span class="comment">//发射一个元素就取消</span></span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p>using用于Flux派生自资源的情况，而且处理完成必须处置资源。<br>让我们使用Disposable替换try-with-resource的AutoCloseable接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AtomicBoolean isDisposed = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">Disposable disposableInstance = <span class="keyword">new</span> Disposable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isDisposed.set(<span class="keyword">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"DISPOSABLE"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p>我们这样使用using()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux =</span><br><span class="line">Flux.using(</span><br><span class="line">        () -&gt; disposableInstance, <span class="comment">//生成资源，返回我们的Disposable</span></span><br><span class="line">        disposable -&gt; Flux.just(disposable.toString()), <span class="comment">//处理资源，返回Flux&lt;T&gt;</span></span><br><span class="line">        Disposable::dispose <span class="comment">//当前面的Flux结束，清理资源</span></span><br><span class="line">);</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>订阅、执行完该序列后，isDisposed变成了true。</p><h4 id="Demonstrating-the-Terminal-Aspect-of-onError"><a href="#Demonstrating-the-Terminal-Aspect-of-onError" class="headerlink" title="Demonstrating the Terminal Aspect of onError"></a>Demonstrating the Terminal Aspect of onError</h4><p>为了证明，发生错误的时候，这些operators导致上游的原始序列结束，看下面使用Flux.interval的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux =</span><br><span class="line">Flux.interval(Duration.ofMillis(<span class="number">250</span>))</span><br><span class="line">    .map(input -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (input &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="string">"tick "</span> + input;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"boom"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .onErrorReturn(<span class="string">"Uh oh"</span>);</span><br><span class="line"></span><br><span class="line">flux.subscribe(System.out::println);</span><br><span class="line">Thread.sleep(<span class="number">2100</span>);</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><p>程序每250毫秒打印一行，输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tick 0</span><br><span class="line">tick 1</span><br><span class="line">tick 2</span><br><span class="line">Uh oh</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><h4 id="Retrying"><a href="#Retrying" class="headerlink" title="Retrying"></a>Retrying</h4><p>关于错误处理，还有一个有趣的operator：retry。<br>它会重新订阅上游的Flux。这实际上是一个不同的序列，源已经结束了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Flux.interval(Duration.ofMillis(<span class="number">250</span>))</span><br><span class="line">    .map(input -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (input &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="string">"tick "</span> + input;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"boom"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .retry(<span class="number">1</span>)</span><br><span class="line">    .elapsed() <span class="comment">//把每个值和上一个值发射以后持续的时间相关联</span></span><br><span class="line">    .subscribe(System.out::println, System.err::println); </span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">2100</span>);</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><p>程序的输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">259,tick 0</span><br><span class="line">249,tick 1</span><br><span class="line">251,tick 2</span><br><span class="line">506,tick 0 &#x2F;&#x2F;新的interval，从0开始</span><br><span class="line">248,tick 1</span><br><span class="line">253,tick 2</span><br><span class="line">java.lang.RuntimeException: boom</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><p>可以看到，retry(1)只重新订阅了一次interval。在第二次，因为还出错，所以错误被传播到下游，序列结束了。<br>还有更先进的retry版本（retryWhen），使用一个伙伴Flux，判断特定的错误是否应该重试。这个伙伴Flux由用户装饰（decorated），自定义retry条件。<br>伙伴Flux是一个Flux，传的参数是Function，返回Publisher&lt;?&gt;。retry这样工作：</p><ul><li>错误发生，被传给伙伴Flux</li><li>如果伙伴Flux发射一个值，retry发生</li><li>如果伙伴Flux完成，retry结束，序列完成</li><li>如果伙伴Flux抛异常e，retry结束，序列抛e</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux = Flux</span><br><span class="line">    .&lt;String&gt;error(<span class="keyword">new</span> IllegalArgumentException()) </span><br><span class="line">    .doOnError(System.out::println) </span><br><span class="line">    .retryWhen(companion -&gt; companion.take(<span class="number">3</span>)); <span class="comment">//重试3次</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p>上面的程序的结果是一个empty Flux，但是它successfully完成了。因为相同Flux上的retry(3) 以最后的错误结束，这个retryWhen例子和retry(3)不完全一样。<br>想达到相同的效果，需要一些技巧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux =</span><br><span class="line">Flux.&lt;String&gt;error(<span class="keyword">new</span> IllegalArgumentException())</span><br><span class="line">    .retryWhen(companion -&gt; companion</span><br><span class="line">    .zipWith(Flux.range(<span class="number">1</span>, <span class="number">4</span>), </span><br><span class="line">          (error, index) -&gt; &#123; </span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">4</span>) <span class="keyword">return</span> index; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">throw</span> Exceptions.propagate(error); </span><br><span class="line">          &#125;)</span><br><span class="line">    );</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><h3 id="Handling-Exceptions-in-Operators-or-Functions"><a href="#Handling-Exceptions-in-Operators-or-Functions" class="headerlink" title="Handling Exceptions in Operators or Functions"></a>Handling Exceptions in Operators or Functions</h3><p>通常，所有的operators自身就包含可能抛异常的代码，调用的用户代码也可能产生类似的失败，所以，都包含失败处理。<br>根据经验，Unchecked Exception总是通过onError传播。比如，在一个map函数内部抛RuntimeException会转换成一个onError事件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"foo"</span>)</span><br><span class="line">    .map(s -&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(s); &#125;)</span><br><span class="line">    .subscribe(v -&gt; System.out.println(<span class="string">"GOT VALUE"</span>),</span><br><span class="line">               e -&gt; System.out.println(<span class="string">"ERROR: "</span> + e));</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p>上面代码的输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: java.lang.IllegalArgumentException: foo</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>Reactor定义了一个异常集合（比如OutOfMemoryError），认为他们是fatal，见Exceptions.throwIfFatal方法。这些错误意味着Reactor不能继续运行，会被抛出。<br>在内部，也存在unchecked exception不能被传播的情况（尤其在订阅和请求阶段），由于并发竞争（concurrency races）可能同时满足onError和onComplete条件。当这些竞争发生的时候，错误可能不能传播给dropped。不过，仍然可以通过定制钩子（hook）做一定程度的管理。</p><p>你可能会问，那Checked Exceptions呢？<br>比如，你调用了申明了会抛异常的方法，还是应该使用try-catch块处理异常。你有几种选择：</p><ul><li>捕获异常，从中恢复。sequence继续</li><li>捕获异常，包装成unchecked异常，然后抛出（中断sequence）。Exceptions类会为你提供帮助</li><li>如果希望返回Flux（比如使用flatMap），可以把异常包装到错误生成中Flux::return Flux.error(checkedException)（序列终止）</li></ul><p>Reactor提供了Exceptions类，你可以使用它，确保只包装checked异常：</p><ul><li>必要的时候，使用Exceptions.propagate包装异常。它首先调用throwIfFatal，不会包装RuntimeException</li><li>使用Exceptions.unwrap得到未包装的原始异常</li></ul><p>比如，下面的方法会抛IOException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"boom "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"OK "</span> + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>现在，你想在map中调用该方法。你必须捕获该异常，而且map函数不能再次抛出它，你可以这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; converted = Flux</span><br><span class="line">    .range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">    .map(i -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="keyword">return</span> convert(i); &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123; <span class="keyword">throw</span> Exceptions.propagate(e); &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>然后，在订阅的时候，可以得到原始异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">converted.subscribe(</span><br><span class="line">    v -&gt; System.out.println(<span class="string">"RECEIVED: "</span> + v),</span><br><span class="line">    e -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (Exceptions.unwrap(e) <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Something bad happened with I/O"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Something bad happened"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><h2 id="Processors"><a href="#Processors" class="headerlink" title="Processors"></a>Processors</h2><p>Processors是特殊的Publisher，而且也是Subscriber。这就是说，你可以subscribe一个Processor（通常，实现了Flux），你也可以调用方法手工注入数据，或者终止它。<br>有几种类型的Processors，每个都有特殊的语义，在你研究之前，应该问自己几个问题：</p><h3 id="Do-I-Need-a-Processor"><a href="#Do-I-Need-a-Processor" class="headerlink" title="Do I Need a Processor?"></a>Do I Need a Processor?</h3><p>应该尽量避免使用Processor，他们不容易正确使用，一般用于特殊场合。<br>如果你认为Processor很适合，就问一下自己，是否尝试过下面两个选择：</p><ul><li>operator，或者他们的组合是否符合要求</li><li>是否可以用 “generator” operator 代替（通常，他们是桥梁API，不是响应式的。提供的sink可以手工填充sequence或者终止它）</li></ul><h3 id="Safely-Produce-from-Multiple-Threads-by-Using-the-Sink-Facade"><a href="#Safely-Produce-from-Multiple-Threads-by-Using-the-Sink-Facade" class="headerlink" title="Safely Produce from Multiple Threads by Using the Sink Facade"></a>Safely Produce from Multiple Threads by Using the Sink Facade</h3><p>和直接使用Processors相比，更好的办法是调用sink() 方法获取Sink。<br>FluxProcessor的Sink是多线程producers。比如，对于UnicastProcessor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UnicastProcessor&lt;Integer&gt; processor = UnicastProcessor.create();</span><br><span class="line">FluxSink&lt;Integer&gt; sink = processor.sink(overflowStrategy);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p>之后，多个生产者线程可以使用sink并发生成数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sink.next(n);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>next方法可能溢出，这由Processor的配置决定：</p><ul><li>无边界的Processor，自己通过dropping或者buffering处理溢出</li><li>有边界的Processor，对于IGNORE策略会阻塞或者旋转（spins），或者定制overflowStrategy</li></ul><h3 id="Overview-of-Available-Processors"><a href="#Overview-of-Available-Processors" class="headerlink" title="Overview of Available Processors"></a>Overview of Available Processors</h3><p>Reactor自带的Processor大致可分为几类：</p><ul><li>direct (DirectProcessor、UnicastProcessor)：只能使用Sink提供数据</li><li>synchronous (EmitterProcessor、ReplayProcessor)：通过用户交互推送数据，或者通过上游Publisher同步排泄</li><li>asynchronous (WorkQueueProcessor、TopicProcessor)：数据来自用户交互，或者多个上游Publishers。他们更强大，有RingBuffer支持</li></ul><p>异步的最复杂，有许多选项。所以，暴露了Builder接口。而其他简单的只有静态工厂方法。</p><h4 id="Direct-Processor"><a href="#Direct-Processor" class="headerlink" title="Direct Processor"></a>Direct Processor</h4><p>Direct Processor可以把信号派发给0个或者多个Subscribers。它不能处理背压。如果最少有一个订阅者请求量少于N，而你推送了N条数据，DirectProcessor就发射IllegalStateException。<br>一旦Processor终止了（一般通过调用它的sink的error(Throwable)或者complete()方法），它允许更多订阅者订阅，但是会立刻重播termination信号。</p><h4 id="Unicast-Processor"><a href="#Unicast-Processor" class="headerlink" title="Unicast Processor"></a>Unicast Processor</h4><p>有内部buffer，可以处理背压。但是，最多只能有一个Subscriber。<br>UnicastProcessor有几个选项，所以有多个工厂方法。比如默认的是unbounded，如果Subscriber还没请求数据，不管你给它多少数据，都会被缓存。<br>也可以使用自定义的Queue，如果该队列是有边界的，processor可以拒绝推送数据。也可以定义一个回调，当队列满了就调用该回调。</p><h4 id="Emitter-Processor"><a href="#Emitter-Processor" class="headerlink" title="Emitter Processor"></a>Emitter Processor</h4><p>Emitter Processor 能够发射给几个订阅者，并尊重每个订阅者的背压。它还可以订阅一个Publisher，同步地中继它的信号。<br>还没有订阅的时候，根据可配置的bufferSize，它只能接受很少的数据。如果还没有Subscriber消费数据，onNext被阻塞。<br>第一个订阅者会收到这些缓存的数据。它不会为后来的订阅者重播数据，后来的订阅者只能收到以后的新数据。<br>默认地。如果全部订阅者都cancelled，它会清除内部缓存，停止接受新的订阅者。可以通过autoCancel参数修改该行为。</p><h4 id="Replay-Processor"><a href="#Replay-Processor" class="headerlink" title="Replay Processor"></a>Replay Processor</h4><p>它缓存数据。或者通过 sink()，或者通过上游Publisher。会为后来的订阅者重播数据。<br>有几种配置：</p><ul><li>缓存单个元素（cacheLast）</li><li>缓存有限的（create(int)），或者无限的（create()）</li><li>缓存基于时间的重播窗口（createTimeout(Duration)）</li><li>大小和时间的组合（createSizeOrTimeout(int, Duration)）</li></ul><h4 id="Topic-Processor"><a href="#Topic-Processor" class="headerlink" title="Topic Processor"></a>Topic Processor</h4><p>异步的。当使用shared配置（builder()的share(boolean)选项）生成的时候，可以中继多个上游Publishers。<br>如果你打算并发调用TopicProcessor的onNext、onComplete或者onError方法，或者来自并发的上游Publisher，会强制使用share选项。<br>它可以有多个Subscribers。它会为每个Subscriber关联一个线程，它会一直运行，知道产生onError或者onComplete信号，或者订阅被取消。订阅者的数量由executor选项决定。<br>它包含RingBuffer，存储推送的信号。Subscriber线程会保存RingBuffer的指针。<br>还有autoCancel选项，默认是true，如果源被cancelled，所有的订阅也都被cancelled。</p><h4 id="WorkQueue-Processor"><a href="#WorkQueue-Processor" class="headerlink" title="WorkQueue Processor"></a>WorkQueue Processor</h4><p>异步的。当使用shared配置（builder()的share(boolean)选项）生成的时候，可以中继多个上游Publishers。<br>它不完全遵循Reactive Streams规范，所以比TopicProcessor节省资源。它也基于RingBuffer，但是不会为每个订阅者增加线程。所以，它比TopicProcessor容易扩展。<br>来自每个订阅者的请求被集中到一起，被中继的信号只发送给一个Subscriber，采用round-robin模式。<br>它的选项和TopicProcessor相同。<br>它不应该有太多的订阅者。否则可能lock该Processor。</p><p>有专属的测试包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.projectreactor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactor-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>主要包括：</p><ul><li>StepVerifier - 一步一步地测试序列</li><li>TestPublisher - 生产数据，测试下游operators的行为</li><li>可选Publisher的序列中（比如使用了switchIfEmpty），确保使用某一个</li></ul><h1 id="Testing-a-Scenario-with-StepVerifier"><a href="#Testing-a-Scenario-with-StepVerifier" class="headerlink" title="Testing a Scenario with StepVerifier"></a>Testing a Scenario with StepVerifier</h1><p>可以一步一步地定义一个测试场景：下一个事件是什么？希望Flux发射一个特定值？或者接下来的300ms什么都不做？他们都可以通过StepVerifier实现。<br>比如下面的Flux装饰代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Flux&lt;T&gt; <span class="title">appendBoomError</span><span class="params">(Flux&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source.concatWith(Mono.error(<span class="keyword">new</span> IllegalArgumentException(<span class="string">"boom"</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>为了测试，你想这样验证：首先发射foo，然后发射bar，然后是产生错误消息boom。<br>使用StepVerifier，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAppendBoomError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要一个源Flux</span></span><br><span class="line">  Flux&lt;String&gt; source = Flux.just(<span class="string">"foo"</span>, <span class="string">"bar"</span>); </span><br><span class="line"></span><br><span class="line">  StepVerifier.create( <span class="comment">//增加StepVerifier builder</span></span><br><span class="line">    appendBoomError(source)) </span><br><span class="line">    .expectNext(<span class="string">"foo"</span>) <span class="comment">//第一个信号是onNext，值是foo</span></span><br><span class="line">    .expectNext(<span class="string">"bar"</span>)</span><br><span class="line">    .expectErrorMessage(<span class="string">"boom"</span>) <span class="comment">//最后一个信号是onError，包含一个boom消息</span></span><br><span class="line">    .verify(); <span class="comment">//触发测试</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p>该API是一个builder。通过增加StepVerifier，把序列传给它来做测试。它提供了下列方法：</p><ul><li>表达式expectations是关于下一个信号的。如果收到其他信号（或者内容不匹配），测试失败，并带有有意义的AssertionError。比如你可以使用expectNext(T…) ，或者expectNextCount(long)</li><li>Consume下一个信号。当你想跳过部分序列，或者想为信号内容使用自定义的assertion的时候（比如，想检查onNext事件，并且发射了包含5条数据的列表）。比如你可以使用consumeNextWith(Consumer)</li><li>其他操作，比如暂停或者运行任意代码。比如，如果想操纵某上下文或者状态，可能会使用thenAwait(Duration)和then(Runnable)</li></ul><p>对于终止事件，相应的expectation方法是expectComplete()和expectError()的变种。最后，你能做些附加配置，然后触发验证，一般是使用verify()或者变种。<br>如果验证失败，抛出AssertionError。</p><h2 id="Better-identifying-test-failures"><a href="#Better-identifying-test-failures" class="headerlink" title="Better identifying test failures"></a>Better identifying test failures</h2><ul><li>as(String)：可用于大多数expect*的后面，描述前面的expectation。如果失败，错误消息包含该描述。终止expectations和verify不能被描述</li><li>StepVerifierOptions.create().scenarioName(String)：使用StepVerifierOptions增加StepVerifier，可以使用scenarioName给整个场景命名。它也会在错误消息中使用</li></ul><p>注意，只有在产生自己的AssertionError的StepVerifier方法，会在消息中使用description/name。</p><h1 id="Manipulating-Time"><a href="#Manipulating-Time" class="headerlink" title="Manipulating Time"></a>Manipulating Time</h1><p>基于时间的operators，可以使用StepVerifier.withVirtualTime。以避免测试长时间运行。<br>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StepVerifier.withVirtualTime(() -&gt; Mono.delay(Duration.ofDays(<span class="number">1</span>)))</span><br><span class="line"><span class="comment">//... continue expectations here</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p>虚拟时间特性，在Schedulers工厂中加入一个定制Scheduler。由于时间operators默认使用Schedulers.parallel()，现在替换成了VirtualTimeScheduler。重要的是：在虚拟时间调度器激活之后，再实例化该operator。<br>为提高成功率，该StepVerifier的输入不是简单的Flux，而是Supplier。这样会延迟生成要测试的flux的实例。<br>一定要确保Supplier&lt;Publisher&lt; T &gt;&gt;的延迟性。该Flux的实例化应该在lambda内。</p><p>有两个和时间相关的expectation，不管是否使用虚拟时间都有效：</p><ul><li>thenAwait(Duration)：暂停评估步骤</li><li>expectNoEvent(Duration)：序列可以继续，如果给定时间内有事件，就失败</li></ul><p>这两个方法在经典方式下会将线程暂停一些时间，在虚拟时间方式下也会改进虚拟时钟。<br>expectNoEvent会认为subscription也是一个事件。如果在第一步使用了它，一般会失败，这是因为检测到了subscription信号。此时，可以使用expectSubscription().expectNoEvent(duration)。</p><p>为了快速评估Mono.delay的行为，可以这样写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StepVerifier.withVirtualTime(() -&gt; Mono.delay(Duration.ofDays(<span class="number">1</span>)))</span><br><span class="line">    .expectSubscription() </span><br><span class="line">    .expectNoEvent(Duration.ofDays(<span class="number">1</span>)) <span class="comment">//1天内什么都没发生</span></span><br><span class="line">    .expectNext(<span class="number">0L</span>) <span class="comment">//然后发射0</span></span><br><span class="line">    .verifyComplete(); <span class="comment">//完成</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><h1 id="Performing-Post-execution-Assertions-with-StepVerifier"><a href="#Performing-Post-execution-Assertions-with-StepVerifier" class="headerlink" title="Performing Post-execution Assertions with StepVerifier"></a>Performing Post-execution Assertions with StepVerifier</h1><p>在最后一个expectation之后，如果想使用assertion API ，而不是触发 verify()。可以使用verifyThenAssertThat()。<br>它返回StepVerifier.Assertions 对象。这样，在场景胜利结束后，可以断言一些状态元素。</p><h1 id="Testing-the-Context"><a href="#Testing-the-Context" class="headerlink" title="Testing the Context"></a>Testing the Context</h1><p>对于上下文的传播，有一些expectations：</p><ul><li>expectAccessibleContext：返回一个ContextExpectations，用来设置expectations 。确保调用then()以返回sequence expectations的设置</li><li>expectNoAccessibleContext：希望测试operators链上，不传播上下文</li></ul><p>可以使用StepVerifierOptions，给StepVerifier关联一个测试初始上下文。代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StepVerifier.create(Mono.just(<span class="number">1</span>).map(i -&gt; i + <span class="number">10</span>),</span><br><span class="line">StepVerifierOptions.create().withInitialContext(Context.of(<span class="string">"foo"</span>, <span class="string">"bar"</span>))) <span class="comment">//有初始Context</span></span><br><span class="line">            .expectAccessibleContext() <span class="comment">//上下文传播expectations</span></span><br><span class="line">            .contains(<span class="string">"foo"</span>, <span class="string">"bar"</span>) <span class="comment">//上下文中，key foo的值是bar</span></span><br><span class="line">            .then() <span class="comment">//切换回正常expectations</span></span><br><span class="line">            .expectNext(<span class="number">11</span>)</span><br><span class="line">            .verifyComplete();<span class="comment">//结束 </span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><h1 id="Manually-Emitting-with-TestPublisher"><a href="#Manually-Emitting-with-TestPublisher" class="headerlink" title="Manually Emitting with TestPublisher"></a>Manually Emitting with TestPublisher</h1><p>对于更高级的测试用例，可能需要完全掌握数据源，以便触发想要的信号。<br>或者你实现了自己的operator，想验证是否满足Reactive Streams规范。</p><p>对此，提供了TestPublisher类。它是Publisher ，可以用程序触发以下信号：</p><ul><li>next(T)、next(T, T…)：触发1-n个onNext信号</li><li>emit(T…) ：发射数据，然后complete()</li><li>complete() ：使用onComplete信号结束</li><li>error(Throwable)：使用onError信号结束</li></ul><p>可以通过create工厂方法获得TestPublisher。也可以使用createNonCompliant工厂方法，它从TestPublisher.Violation枚举中接受一个值或者多个值。这些值规定了发布者可以忽略规范的哪些部分：</p><ul><li>REQUEST_OVERFLOW：即使请求不足，也允许调用next，不会抛IllegalStateException</li><li>ALLOW_NULL：对于null，也允许调用next，不会抛NullPointerException</li><li>CLEANUP_ON_TERMINATE：允许发送多次终止信号。包括complete()、 error()和emit()</li><li>DEFER_CANCELLATION：允许忽略cancel信号，继续发送信号</li></ul><p>TestPublisher会在订阅以后跟踪内部状态，以使用assert*方法。</p><h1 id="Checking-the-Execution-Path-with-PublisherProbe"><a href="#Checking-the-Execution-Path-with-PublisherProbe" class="headerlink" title="Checking the Execution Path with PublisherProbe"></a>Checking the Execution Path with PublisherProbe</h1><p>当构建复杂operators链的时候，可能会有多个执行路径，对应不同的子序列。<br>大多数情况下，这些子序列能够生产足够的onNext信号，可以执行到最后。<br>比如下面的例子，如果源是空的，就使用switchIfEmpty：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Flux&lt;String&gt; <span class="title">processOrFallback</span><span class="params">(Mono&lt;String&gt; source, Publisher&lt;String&gt; fallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source</span><br><span class="line">            .flatMapMany(phrase -&gt; Flux.fromArray(phrase.split(<span class="string">"\\s+"</span>)))</span><br><span class="line">            .switchIfEmpty(fallback);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>很容易测试switchIfEmpty对应的逻辑分支：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitPathIsUsed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StepVerifier.create(processOrFallback(Mono.just(<span class="string">"just a  phrase with    tabs!"</span>), Mono.just(<span class="string">"EMPTY_PHRASE"</span>)))</span><br><span class="line">                .expectNext(<span class="string">"just"</span>, <span class="string">"a"</span>, <span class="string">"phrase"</span>, <span class="string">"with"</span>, <span class="string">"tabs!"</span>)</span><br><span class="line">                .verifyComplete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEmptyPathIsUsed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StepVerifier.create(processOrFallback(Mono.empty(), Mono.just(<span class="string">"EMPTY_PHRASE"</span>)))</span><br><span class="line">                .expectNext(<span class="string">"EMPTY_PHRASE"</span>)</span><br><span class="line">                .verifyComplete();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure><p>但是，考虑另一个例子，方法生产的是Mono。它等待源完成，执行附加任务，然后完成。如果源是空的，执行Runnable类型的任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Mono&lt;String&gt; <span class="title">executeCommand</span><span class="params">(String command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Mono.just(command + <span class="string">" DONE"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">processOrFallback</span><span class="params">(Mono&lt;String&gt; commandSource, Mono&lt;Void&gt; doWhenEmpty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commandSource</span><br><span class="line">            .flatMap(command -&gt; executeCommand(command).then()) <span class="comment">//then()忘记了command的返回。它只关心已经完成了</span></span><br><span class="line">            .switchIfEmpty(doWhenEmpty); <span class="comment">//如何区分两个都是空序列的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><p>为了验证processOrFallback确实执行了doWhenEmpty路径，你需要写boilerplate。就是说，你需要一个Mono ：</p><ul><li>它确实被订阅了</li><li>整个处理结束后，断言该事实</li></ul><p>在 3.1之前，你需要为每个想要断言的状态，手工维护一个AtomicBoolean，并将相应的doOn*回调附加到要评估的发布者。从3.1.0开始，可以使用PublisherProbe：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCommandEmptyPathIsUsed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PublisherProbe&lt;Void&gt; probe = PublisherProbe.empty(); <span class="comment">//翻译空序列</span></span><br><span class="line"></span><br><span class="line">    StepVerifier.create(processOrFallback(Mono.empty(), probe.mono())) <span class="comment">//使用probe.mono()代替Mono&lt;Void&gt; </span></span><br><span class="line">                .verifyComplete();</span><br><span class="line"></span><br><span class="line">    probe.assertWasSubscribed(); <span class="comment">//序列完成后，确保使用了probe</span></span><br><span class="line">    probe.assertWasRequested(); <span class="comment">//以及实际请求的数据</span></span><br><span class="line">    probe.assertWasNotCancelled(); <span class="comment">//没有被取消</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><p>本方法，对Flux&lt; T &gt;也有效。对于需要探测执行路径，也需要探测数据的情况，你可以使用PublisherProbe.of(Publisher)包装任何Publisher&lt; T &gt;。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;About-the-Documentation&quot;&gt;&lt;a href=&quot;#About-the-Documentation&quot; class=&quot;headerlink&quot; title=&quot;About the Documentation&quot;&gt;&lt;/a&gt;About the Documen
      
    
    </summary>
    
      <category term="reactor" scheme="http://yoursite.com/categories/reactor/"/>
    
    
      <category term="reactor" scheme="http://yoursite.com/tags/reactor/"/>
    
  </entry>
  
  <entry>
    <title>dubbo 问题</title>
    <link href="http://yoursite.com/wiki/dubbo/dubbo%20%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/wiki/dubbo/dubbo 问题/</id>
    <published>2019-07-07T01:56:06.439Z</published>
    <updated>2020-04-22T11:45:24.521Z</updated>
    
    <content type="html"><![CDATA[<h4 id="dubbo-问题"><a href="#dubbo-问题" class="headerlink" title="dubbo 问题"></a>dubbo 问题</h4><p>1.dubbo adapter 如何实现动态切换服务实现者</p><p>  A.通过动态代理</p><p>  B.通过适配器 加 URL BUS</p><p>  C.通过动态代理加URL BUS </p><p>2.dubbo filter 如何动态扩展业务功能</p><p>  A.改写ProtocolFilterWrapper</p><p>  B.加protocol装饰类</p><p>  C.在Meta-INF扩充</p><p>3.dubbo 不同功能使用不同协议是如何实现</p><p>  A.扩充protocl接口协议，指定protocol名，由ExtensionLoader来获取</p><p>  B.直接通过ExtensionLoader 加载指定协议</p><p>  C.全自动匹配</p><p>4.dubbo cluster 服务容错如何实现</p><p>  A.根据failfast,failover,failback 等策略，通过异常分支决心决定如何选择invoker交互 最终决定result状态</p><p>  B.调用invoker失败直接返回异常,由业务处理异常流程</p><p>  C.通过router 过滤 invoker集合 再负载均衡调用，遇见异常走不同的回调策略或mock</p><p>5.dubbo 负载均衡权重 如何动态变更</p><p>  A.zk回调provider通知invoker 权重值变更,负载均衡获得最新invoker权重进行负载调用</p><p>  B.zk回调provider通知invoker的method权重值变更,负载均衡获得最新invoker method权重进行负载调用</p><p>  C.通过api直接动态改变</p><p>2.6</p><p>Sofa  dubbo  sentinel nacos seata etcd</p><p>Rocket MQ  Kafka grpc  Rsocket</p><p>1.RPC 通信原理</p><ul><li><p>RPC 是什么&amp;底层原理是什么&amp;解决什么问题[API调用弊端]&amp;怎么实现</p></li><li><p>RPC核心基础功能具备哪几个？</p></li><li><p>RPC框架在项目中的根本作用</p></li><li><p>RPC为什么不能用HTTP协议，而是RPC协议</p></li><li><p>服务治理是什么东东？服务怎么治理？</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;dubbo-问题&quot;&gt;&lt;a href=&quot;#dubbo-问题&quot; class=&quot;headerlink&quot; title=&quot;dubbo 问题&quot;&gt;&lt;/a&gt;dubbo 问题&lt;/h4&gt;&lt;p&gt;1.dubbo adapter 如何实现动态切换服务实现者&lt;/p&gt;
&lt;p&gt;  A.通过动态代
      
    
    </summary>
    
      <category term="dubbo" scheme="http://yoursite.com/categories/dubbo/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Java-NIO</title>
    <link href="http://yoursite.com/wiki/netty/Java%20NIO/"/>
    <id>http://yoursite.com/wiki/netty/Java NIO/</id>
    <published>2019-06-12T07:56:26.913Z</published>
    <updated>2020-04-22T11:45:48.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>Java NIO 中的 Buffer 用于和 NIO 通道进行交互。如你所知，数据是从通道读入缓冲区，从缓冲区写入到通道中的。</p><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成 NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</p><h5 id="Buffer的基本用法"><a href="#Buffer的基本用法" class="headerlink" title="Buffer的基本用法"></a>Buffer的基本用法</h5><p>使用 Buffer 读写数据一般遵循以下四个步骤</p><blockquote><p>1.写入数据到Buffer</p><p>2.调用 flip() 方法</p><p>3.从 Buffer 中读取数据</p><p>4.调用 clear() 方法或者 compact() 方法</p></blockquote><p>当向 buffer 写入数据是，buffer 会记录下写了多少数据。一旦要读取数据，需要通过 <code>flip()</code> 方法将 Buffer 从写的模式切换到读的模式。在读的模式下，可以读取之前写入到 buffer 的所有数据。</p><p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：<code>调用clear() 或 compact()</code> 方法。 <code>clear()</code> 方法会清空整个缓冲区。<code>compact()</code> 方法只会清除已经读过的数据。任何未读的数据都被迁到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p><p>下面是一个使用Buffer 的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"/nio-dta.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//create buffer with capacity of 48 bytes</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);<span class="comment">//read into buffer</span></span><br><span class="line"><span class="keyword">while</span>(bytesRead != -<span class="number">1</span>)&#123;</span><br><span class="line">  buf.flip();<span class="comment">//make buffer ready for read</span></span><br><span class="line">  <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>)buf.get());<span class="comment">//read 1 byte at a time</span></span><br><span class="line">  &#125;</span><br><span class="line">  buf.clear();<span class="comment">//make buffer ready for writing</span></span><br><span class="line">  bytesRead = inChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure><h5 id="Buffer的capacity，position和limit"><a href="#Buffer的capacity，position和limit" class="headerlink" title="Buffer的capacity，position和limit"></a>Buffer的capacity，position和limit</h5><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成 NIO Buffer 对象，并提供了一组方法，用来方便的访问该块内存。</p><p>为了理解 Buffer 的工作原理，需要熟悉它的三个属性：</p><blockquote><ul><li>capacity</li><li>position</li><li>limit</li></ul></blockquote><p>position 和 limit 的含义取决于 Buffer 处在读模式还是写模式。不管 Buffer 处在什么模式，capacity 的含义总是一样的。关于capacity ， position 和 limit 在读写模式中的说明如下：</p><p><img src="/Users/guoyin/Library/Application Support/typora-user-images/image-20190612161959232.png" alt="image-20190612161959232"></p><p>capacity</p><blockquote><p>作为一个内存块，Buffer 有一个固定的大小值，也叫”capacity”。你只能往里写 capacity 个 byte 、long、char 等类型。一旦 Buffer 满了，需要将其清空(通过读数据或者清除数据) 才能继续写数据往里写数据。</p></blockquote><p>position</p><blockquote><p>当你写数据到 Buffer 中时，position 表示当前的位置。初始的position 值为 0 。当一个byte、long等数据写到 Buffer 后，position 会向前移动到下一个可插入数据的 Buffer 单元。 position 最大可为 capacity -1.</p><p>当读取数据是，也是从某个特定位置读。当将 Buffer 从写模式切换到读模式，position 会被重置为 0 ，当从 Buffer 的position 处读取数据时， position 向前移动到下一个可读取的位置。</p></blockquote><p>limit</p><blockquote><p>在写模式下，Buffer 的 limit 表示你最多能往里写多少数据。写模式下，limit 等于 capacity。当切换 Buffer 到读的模式是， limit 表示最多能读取多少数据。 因此，当切换 Buffer 到读模式时，limit 会被设置成写模式下的 position 值。</p></blockquote><h5 id="Buffer的类型"><a href="#Buffer的类型" class="headerlink" title="Buffer的类型"></a>Buffer的类型</h5><p>Java NIO 有以下 Buffer 类型</p><blockquote><p>ByteBuffer、MappedByteBuffer、CharBuffer、DoubleBuffer、</p><p>FloatBuffer、IntBuffer、LongBuffer、ShortBuffer</p></blockquote><p>这些 Buffer 类型代表了不同的数据类型。换句话说，可以通过char/short/int/long/float或者double 类型来操作缓冲区的字节。MppedByteBuffer有些特殊。</p><h5 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h5><p>要想获得一个 Buffer 对象首先要进行分配。每一个 Buffer 类都有一个 allocate 方法。下面是一个分配 48 字节capacity 的 ByteBuffer 的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br></pre></td></tr></table></figure><p>这是分配一个可存储1024个字符的 CharBuffer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer buf = CharBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><h5 id="向Buffer中写数据"><a href="#向Buffer中写数据" class="headerlink" title="向Buffer中写数据"></a>向Buffer中写数据</h5><p>写数据到 Buffer 有两种方式:</p><blockquote><ul><li><p>从 Channel 写到 Buffer。</p></li><li><p>通过 Buffer 的 put() 方法写到 Buffer里。</p></li></ul></blockquote><p>1.从 Channel 写到 Buffer 的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> byteRead = inChannel.read(buf);<span class="comment">//read intO buffer.</span></span><br></pre></td></tr></table></figure><p>2.通过 <code>put()</code>  方法写到 Buffer 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put(<span class="number">127</span>);</span><br></pre></td></tr></table></figure><pre><code>put 方法有很多版本，允许以不同的方式把数据写入到 Buffer 中。 例如，写到一个指定的位置，或者把一个字节数组写入到 Buffer 。 更多 Buffer 实现的细节参考 JavaDoc。</code></pre><h5 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h5><p><code>flip()</code> 方法将 Buffer 从写模式切换到读模式。 调用 <code>flip()</code> 方法会将 <code>position</code> 设回 0，并将 limit 设置成之前 position 的值。换句话说，position 现在用于标记读的位置，limit 表示之前写进了多少个byte、char 等—现在能读取多少个byte、char 等。</p><h5 id="从Buffer中读取数据"><a href="#从Buffer中读取数据" class="headerlink" title="从Buffer中读取数据"></a>从Buffer中读取数据</h5><p>从 Buffer 中读取数据有两种方式：</p><blockquote><p>1.从 Buffer 读取数据到 Channel。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//read from buffer into channel.</span></span><br><span class="line">&gt;<span class="keyword">int</span> bytesWritten = inChannel.write(buf);</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>2.使用 <code>get()</code> 方法从 Buffer 中读取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">byte</span> aByte = buf.get();</span><br></pre></td></tr></table></figure><p><code>get()</code> 方法有很多版本，允许你以不同的方式从 Buffer 中读取数据。 例如，从指定 position 读取，或者从 Buffer 中读取数据到字节数组。更多参考JavaDoc.</p></blockquote><h5 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind() 方法"></a>rewind() 方法</h5><blockquote><p>Buffer.rewind() 将 position 设回 0，所以你可以重读 Buffer 中的所有数据。 limit 保持不变，任然表示能从 Buffer 中读取多少个元素。</p></blockquote><h5 id="clear-与compact-方法"><a href="#clear-与compact-方法" class="headerlink" title="clear() 与compact()方法"></a>clear() 与compact()方法</h5><p>一旦读完 Buffer 中的数据， 需要让 Buffer 准备好再次被写入。可以通过 <code>clear()</code> 或 <code>compact()</code> 方法来实现。</p><p>如果调用的事 <code>clear()</code> 方法，position 将被设回0，limit 被设置成 capacity 的值。换句话说，Buffer 被清空了，Buffer 中的数据并未清除，只是这些标记告诉我们可以从哪里开始往 Buffer 里写数据。</p><p>如果 Buffer 中有一些未读的数据，调用 <code>clear()</code> 方法，数据将”被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。</p><p>如果 Buffer 中仍有未读取的数据， 且后续还需要这些数据，但是此时想要先先写些数据，那么使用 <code>compact()</code> 方法。 <code>compact()</code> 方法将所有未读取的数据拷贝到 Buffer 起始处。然后 position 设到最后一个未读元素正后面。limit 属性依然像 <code>clear()</code> 方法一样，设置成capacity。现在 Buffer 准备写数据了，但是不会覆盖未读的数据。</p><h5 id="mark-与reset-方法"><a href="#mark-与reset-方法" class="headerlink" title="mark()与reset()方法"></a>mark()与reset()方法</h5><p>通过调用 Buffer.mark() 方法，可以标记Buffer 中一个特定 position. 之后可以通过调用 Buffer.reset() 方法恢复到这个 position 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();</span><br><span class="line"><span class="comment">//call buffer.get() a couple of times, e.g during parsing.</span></span><br><span class="line">buffer.reset();<span class="comment">//set position back to mark.</span></span><br></pre></td></tr></table></figure><h5 id="equals-与compareTo-方法"><a href="#equals-与compareTo-方法" class="headerlink" title="equals()与compareTo()方法"></a>equals()与compareTo()方法</h5><p><code>equals()</code> 方法</p><p><code>equals()</code> 方法只是比较 Buffer 的一部分，不是每一个在它里面的元素都比较。实际上，它只比较 Buffer 中的剩余元素。当满足下列条件时，表示两个 Buffer 相等：</p><blockquote><p>1.有相同的类型(byte、char、int 等)。</p><p>2.Buffer 中剩余的byte、char等的个数相等。</p><p>3.Buffer 中所有剩余的byte、char等都相同。</p></blockquote><p><code>compareTo()</code> 方法</p><p><code>compareTo()</code> 方法比较两个 Buffer 的剩余元素(byte、char等)，如果满足下列条件，则认为一个 Buffer “小于” 另一个 Buffer：</p><blockquote><p>1.第一个不相等的元素小于另一个Buffer 中对应的元素。</p><p>2.所有元素都相等，但第一个Buffer 比另一个先耗尽(第一个 Buffer 的元素个数比另一个少)。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java-NIO&quot;&gt;&lt;a href=&quot;#Java-NIO&quot; class=&quot;headerlink&quot; title=&quot;Java NIO&quot;&gt;&lt;/a&gt;Java NIO&lt;/h2&gt;&lt;h3 id=&quot;Buffer&quot;&gt;&lt;a href=&quot;#Buffer&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="netty" scheme="http://yoursite.com/categories/netty/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/tags/netty/"/>
    
  </entry>
  
</feed>
