<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    
    <title>reactor guid | 旺仔-空间</title>
    
    
        <meta name="keywords" content="reactor">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="About the Documentation本节简要概述了Reactor参考文档。不需要一行一行地阅读本指南，每一节都是独立的，尽管他们经常互相引用。 Getting StartedIntroducing ReactorReactor是JVM上的完全非阻塞的响应式编程框架，支持有效的需求管理（通过背压的方式）。它直接与Java 8的函数式API集成，特别是CompletableFuture、St">
<meta property="og:type" content="article">
<meta property="og:title" content="reactor guid">
<meta property="og:url" content="http://yoursite.com/wiki/reactor/reactor_3_guid_%E7%BF%BB%E8%AF%91%E4%B8%8D%E5%85%A8/index.html">
<meta property="og:site_name" content="旺仔-空间">
<meta property="og:description" content="About the Documentation本节简要概述了Reactor参考文档。不需要一行一行地阅读本指南，每一节都是独立的，尽管他们经常互相引用。 Getting StartedIntroducing ReactorReactor是JVM上的完全非阻塞的响应式编程框架，支持有效的需求管理（通过背压的方式）。它直接与Java 8的函数式API集成，特别是CompletableFuture、St">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190424153103201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM2NDE3Mg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190424153123756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM2NDE3Mg==,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2020-01-10T05:47:02.197Z">
<meta property="article:modified_time" content="2020-04-22T11:47:58.241Z">
<meta property="article:author" content="Gordon gy">
<meta property="article:tag" content="reactor">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190424153103201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM2NDE3Mg==,size_16,color_FFFFFF,t_70">
    

    
        <link rel="alternate" href="/atom.xml" title="旺仔-空间" type="application/atom+xml">
    

    
        <link rel="icon" href="/favicon.ico">
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">

    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
<script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"></head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">旺仔-空间</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/tags">标签</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/tags">标签</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id="categories">
        <h3 class="widget-title">
            <span>分类</span>
            &nbsp;
            <a id="allExpand" href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            dubbo
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/dubbo/dubbo%20%E9%97%AE%E9%A2%98/">dubbo 问题</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            nacos
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/nacos/nacos/">Nacos 实战</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            netty
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/netty/Java%20NIO/">Java-NIO</a></li>  <li class="file"><a href="/wiki/netty/Netty-new%E7%AC%94%E8%AE%B0/">Netty-ByteBuf</a></li>  <li class="file"><a href="/wiki/netty/netty-action/">netty源码解析</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            reactor
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file active"><a href="/wiki/reactor/reactor_3_guid_%E7%BF%BB%E8%AF%91%E4%B8%8D%E5%85%A8/">reactor guid</a></li>  </ul> 
                    </li> 
                     </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-reactor/reactor_3_guid_翻译不全" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/reactor/">reactor</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/reactor/" rel="tag">reactor</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/wiki/reactor/reactor_3_guid_%E7%BF%BB%E8%AF%91%E4%B8%8D%E5%85%A8/">
            <time datetime="2020-01-10T05:47:02.197Z" itemprop="datePublished">2020-01-10</time>
        </a>
    </div>


                        
                            <i class="fa fa-bar-chart"></i>
                            <span id="busuanzi_container_site_pv"><span id="busuanzi_value_page_pv"></span></span>    
                        
                        
                    </div>
                
                
    
        <h1 class="article-title" itemprop="name">
            reactor guid
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <h1 id="About-the-Documentation"><a href="#About-the-Documentation" class="headerlink" title="About the Documentation"></a>About the Documentation</h1><p>本节简要概述了Reactor参考文档。不需要一行一行地阅读本指南，每一节都是独立的，尽管他们经常互相引用。</p>
<h1 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h1><h2 id="Introducing-Reactor"><a href="#Introducing-Reactor" class="headerlink" title="Introducing Reactor"></a>Introducing Reactor</h2><p>Reactor是JVM上的完全非阻塞的响应式编程框架，支持有效的需求管理（通过背压的方式）。它直接与Java 8的函数式API集成，特别是CompletableFuture、Stream和Duration。它提供了可组合的异步序列（asynchronous sequence）API：Flux（用于[N]个元素）和Mono（用于 [0|1]个元素）。广泛实现了<a href="https://www.reactive-streams.org/" target="_blank" rel="external nofollow noopener noreferrer">Reactive Streams</a>。<br>使用reactor-netty，Reactor也支持非阻塞的进程间通信。配合微服务架构，Reactor Netty为HTTP（包括Websockets）、TCP和UDP提供了背压的网络引擎。完全支持响应式的Encoding和Decoding。</p>
<h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><p>Reactor Core最低支持Java 8。<br>它依赖org.reactivestreams:reactive-streams:1.0.2。</p>
<p>Android支持：</p>
<ul>
<li>Reactor 3没有正式支持Android（RxJava 2支持）</li>
<li>在Android SDK 26以上可以工作得很好</li>
</ul>
<h1 id="Introduction-to-Reactive-Programming"><a href="#Introduction-to-Reactive-Programming" class="headerlink" title="Introduction to Reactive Programming"></a>Introduction to Reactive Programming</h1><p>Reactor是响应式编程范式的一个实现，可以概括为：<br>响应式编程是关于数据流和变化传播（the propagation of change）的异步编程范式。这意味着可以通过采用的编程语言轻松地表达静态（比如数组）或者动态（比如事件发送器）的数据流。<br>见<a href="https://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="external nofollow noopener noreferrer">Reactive_programming</a></p>
<p><a href="http://xn--microsoft-322o603cu08b.net/" target="_blank" rel="external nofollow noopener noreferrer">Microsoft最先在.NET</a> ecosystem增加了Reactive Extensions(Rx)库。然后，RxJava在JVM上实现了响应式编程。后来，通过Reactive Streams实现了Java上的标准化-Flow类定义的接口集和交互规则集成到了Java 9内。<br>响应式编程范式通常在面向对象的语言中出现，是Observer设计模式的扩展。比较一下响应式流和Iterator设计模式，一个主要不同点是，Iterator是pull-based的，而响应式流是push-based。<br>使用一个迭代器是一种命令式的编程模式，尽管访问值的方法完全是Iterable的责任。开发人员可以选择何时访问序列中的next()项。<br>而响应式流，是发布-订阅模式的。发布者提醒订阅者来了新值，这种push是响应式的关键。除了推送值，还以明确定义的方式，涵盖错误处理和完成。通过调用onNext，发布者将新值推送给订阅者。也可以通过调用onError发送一个错误信号，或者通过onComplete完成。错误和完成都会终止序列，可以概括为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onNext x 0..N [onError | onComplete]</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>这种方法非常灵活，它支持没有值、一个值和n个值（包括无限的值序列，比如时钟的连续滴答）。</p>
<p>但是，为什么需要一个异步的响应式库呢？</p>
<h2 id="Blocking-Can-Be-Wasteful"><a href="#Blocking-Can-Be-Wasteful" class="headerlink" title="Blocking Can Be Wasteful"></a>Blocking Can Be Wasteful</h2><p>现代程序可以覆盖大量并发用户，虽然硬件性能在持续提升，可软件性能还是一个关键问题。<br>有两种办法提高程序性能：</p>
<ul>
<li>parallelize：采用更多线程和更多硬件资源</li>
<li>seek more efficiency：寻求当前资源的更高效率</li>
</ul>
<p>一般来说，Java程序都是阻塞式的。容易达到性能瓶颈，就需要更多线程，运行类似的阻塞代码。这样做，很快就会出现争用和并发问题。<br>更糟糕的是，阻塞浪费资源。如果仔细观察，一旦程序涉及延迟（特别是I/O，比如数据库操作和网络调用），资源就会被浪费-因为线程处于空闲或者等待数据的状态。</p>
<h2 id="Asynchronicity-to-the-Rescue"><a href="#Asynchronicity-to-the-Rescue" class="headerlink" title="Asynchronicity to the Rescue?"></a>Asynchronicity to the Rescue?</h2><p>也可以编写异步的、非阻塞的代码，使用相同的底层资源切换到其他活动任务，等异步处理执行完成再切换回来。<br>在JVM内，怎么写异步代码呢？</p>
<ul>
<li>Callbacks：异步方法没有返回值，但是需要额外的回调参数（lambda或者匿名类），结果有效时就调用该参数。比如Swing中的EventListener</li>
<li>Futures：异步方法立即返回Future。异步过程计算T的值，Future对象包装了对值的访问。该值不会立即有效，值有效以后才可以拉取（poll）。比如运行Callable任务的ExecutorService使用Future对象</li>
</ul>
<p>这两种方法都有局限性。<br>Callbacks很难组合到一起。阅读和维护起来也很困难。</p>
<h2 id="From-Imperative-to-Reactive-Programming"><a href="#From-Imperative-to-Reactive-Programming" class="headerlink" title="From Imperative to Reactive Programming"></a>From Imperative to Reactive Programming</h2><p>诸如Reactor这样的响应式库不但解决上述缺点，还关注其他方面：</p>
<ul>
<li>组合性和可读性</li>
<li>数据作为流（flow），有丰富的operators</li>
<li>subscribe前什么都没发生</li>
<li>Backpressure，消费者向生产者发送明确的信号，表明生产得太快了</li>
<li>与并发无关的高级抽象</li>
</ul>
<h3 id="Composability-and-Readability"><a href="#Composability-and-Readability" class="headerlink" title="Composability and Readability"></a>Composability and Readability</h3><p>composability是指有能力编排多个异步任务，前一个任务的结果就是后续任务的输入，或者使用fork-join执行几个任务，也可以重用任务，把它作为更高级系统的组件。<br>编排任务的能力与代码的可读性和可维护性紧密相关。随着异步过程层级的数量和复杂性的增加，编写和阅读代码都变得越来越难。正如我们所看到的，回调很简单，但它的一个主要缺点是，对于复杂的过程，你需要在回调中执行回调，他们嵌套在一起（Callback Hell）。<br>Reactor提供了丰富的组合选项，代码反应了抽象过程的组织，全都位于同一级（嵌套最小化）。</p>
<h3 id="The-Assembly-Line-Analogy"><a href="#The-Assembly-Line-Analogy" class="headerlink" title="The Assembly Line Analogy"></a>The Assembly Line Analogy</h3><p>你可以想象为，响应式程序里的数据在装配线上移动。Reactor既是传送带，又是工作站。原材料从源注入（Publisher），最终的成品推送给消费者（Subscriber）。<br>原材料经历各种转换和其他中间步骤，或者是大型装配线上的一部分和其他部件聚合到一起。如果在某一点出现了故障或者堵塞（也许花费了太长时间），受影响的工作站可以向上游信号以限制原材料的流动。</p>
<h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h3><p>Reactor中，operators就是装配线类比中的工作站。每个operator都会向Publisher添加行为，并把前一步的Publisher包装成新的实例。整个链就这样形成了，数据从第一个Publisher沿着链向后移动，由每个link转发。最终，Subscriber完成了该过程。记住，在Subscriber订阅Publisher前，什么都没发生。<br>Reactive Streams规范根本没有指定任何operators，Reactor的最佳附加值就是添加了丰富的operators。他们涉及很多方面，从简单的转换、过滤到复杂的编排和错误处理。</p>
<h3 id="Nothing-Happens-Until-You-subscribe"><a href="#Nothing-Happens-Until-You-subscribe" class="headerlink" title="Nothing Happens Until You subscribe()"></a>Nothing Happens Until You subscribe()</h3><p>Reactor中，当你写一个Publisher链，默认情况下，数据不会启动。你要增加一个异步处理的抽象描述（帮助重用和组合）。<br>通过订阅，把Publisher绑定到Subscriber，从而出发整个链中的数据流。在内部，Subscriber发送一个request信号，向上游传递，直到Publisher。</p>
<h3 id="Backpressure"><a href="#Backpressure" class="headerlink" title="Backpressure"></a>Backpressure</h3><p>backpressure也是通过向上游传递信号实现的，还是用装配线做类比，如果工作站处理得比上游慢就发送一个反馈信号。<br>Reactive Streams规范的定义非常接近类比：subscriber可以在unbounded模式工作，让源以最快的速度推送数据;或者使用request机制，向源发信号，它现在可以处理最多n条数据。<br>中间operators也可以改变request。比如buffer operator，可以把数据分组。还有些operators实现了prefetching策略，这就避免了request(1)往返，如果在请求之前就生成元素不太昂贵，这样处理是划算的。<br>这样，把push模式变成了push-pull，如果有数据，下游可以从上游pull数据。如果没有数据，就等数据准备好以后push给下游。</p>
<h3 id="Hot-vs-Cold"><a href="#Hot-vs-Cold" class="headerlink" title="Hot vs Cold"></a>Hot vs Cold</h3><p>有两大类反应式序列hot和cold。主要区别是响应式流如何应答订阅：</p>
<ul>
<li>Cold：为每个Subscriber都生成新的序列，包括数据源。比如，如果源包装了一个HTTP调用，就为每个订阅生成一个新的HTTP请求</li>
<li>Hot：对于每个Subscriber，不会重新开始。相反，迟到的订阅者只能接收到订阅之后发射的数据。注意，一些hot响应式流可以缓存或者重放历史（甚至全部历史）。hot的序列甚至可以在没有订阅者时也发射数据</li>
</ul>
<h1 id="Reactor-Core-Features"><a href="#Reactor-Core-Features" class="headerlink" title="Reactor Core Features"></a>Reactor Core Features</h1><p>Reactor提供了可组合的响应式类型，他们（Flux和Mono）实现了Publisher，还提供了丰富的operators。Flux代表0…N个元素，Mono代表(0…1)。<br>比如，HTTP请求只有一个响应，所以应该不会做count运算。所以，使用Mono代表一次HTTP请求的结果会更好。<br>改变最大基数的Operators会切换相关类型。比如，Flux才有count运算，但是它返回Mono。</p>
<h2 id="Flux-an-Asynchronous-Sequence-of-0-N-Items"><a href="#Flux-an-Asynchronous-Sequence-of-0-N-Items" class="headerlink" title="Flux, an Asynchronous Sequence of 0-N Items"></a>Flux, an Asynchronous Sequence of 0-N Items</h2><p><img src="https://img-blog.csdnimg.cn/20190424153103201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM2NDE3Mg==,size_16,color_FFFFFF,t_70" alt="Flux"></p>
<p>Flux是一个标准的Publisher，可以由一个completion信号或者error终止。三种类型的信号转换为对下游Subscriber的onNext、onComplete或者onError方法的调用。<br>所有的事件，包括terminating，都是可选的。如果没有onNext事件但是有onComplete代表一个empty有限序列;而删除了onComplete，就变成一个无限的空序列（没什么用，除非要测试cancellation）。<br>无限序列不一定是空的，比如，Flux.interval(Duration)生产的Flux就是无限的，根据时钟发出滴答声。</p>
<h2 id="Mono-an-Asynchronous-0-1-Result"><a href="#Mono-an-Asynchronous-0-1-Result" class="headerlink" title="Mono, an Asynchronous 0-1 Result"></a>Mono, an Asynchronous 0-1 Result</h2><p><img src="https://img-blog.csdnimg.cn/20190424153123756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM2NDE3Mg==,size_16,color_FFFFFF,t_70" alt="Mono"></p>
<p>Mono 是一个专用的Publisher，最多发送一条数据，然后可以由onComplete或者onError信号终止。<br>只包含Flux的operators的子集，一些operators可以切换到Flux。<br>比如，Mono#concatWith(Publisher)返回一个Flux，Mono#then(Mono) 返回另一个Mono。<br>Mono可以代表一个无值的异步处理，它仅有completion概念（类似Runnable）。想增加这样一个，请使用Mono。</p>
<h2 id="Simple-Ways-to-Create-a-Flux-or-Mono-and-Subscribe-to-It"><a href="#Simple-Ways-to-Create-a-Flux-or-Mono-and-Subscribe-to-It" class="headerlink" title="Simple Ways to Create a Flux or Mono and Subscribe to It"></a>Simple Ways to Create a Flux or Mono and Subscribe to It</h2><p>可以使用工厂方法开始使用Flux和Mono。<br>比如，要增加一个String序列，可以枚举他们，可以放进集合，然后增加Flux：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; seq1 = Flux.just(<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"foobar"</span>);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; iterable = Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"foobar"</span>);</span><br><span class="line">Flux&lt;String&gt; seq2 = Flux.fromIterable(iterable);</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>其他例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有值，也可以使用泛型</span></span><br><span class="line">Mono&lt;String&gt; noData = Mono.empty(); </span><br><span class="line"></span><br><span class="line">Mono&lt;String&gt; data = Mono.just(<span class="string">"foo"</span>);</span><br><span class="line"><span class="comment">//第一个参数是范围的开始，第二个参数是数量</span></span><br><span class="line">Flux&lt;Integer&gt; numbersFromFiveToSeven = Flux.range(<span class="number">5</span>, <span class="number">3</span>); </span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>订阅的时候，Flux和Mono支持Java 8 lambdas。可以选择.subscribe()的变种，将lambdas用于不同的回调组合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//订阅，触发一个序列</span></span><br><span class="line">subscribe(); </span><br><span class="line"><span class="comment">//使用每个产生的值做点啥</span></span><br><span class="line">subscribe(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer); </span><br><span class="line"><span class="comment">//处理值，也响应错误</span></span><br><span class="line">subscribe(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer,</span><br><span class="line">          Consumer&lt;? <span class="keyword">super</span> Throwable&gt; errorConsumer); </span><br><span class="line"><span class="comment">//处理值和错误。当序列successfully完成时，做点啥</span></span><br><span class="line">subscribe(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer,</span><br><span class="line">          Consumer&lt;? <span class="keyword">super</span> Throwable&gt; errorConsumer,</span><br><span class="line">          Runnable completeConsumer); </span><br><span class="line"><span class="comment">//处理值、错误和successful完成。再使用Subscription做点什么</span></span><br><span class="line">subscribe(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer,</span><br><span class="line">          Consumer&lt;? <span class="keyword">super</span> Throwable&gt; errorConsumer,</span><br><span class="line">          Runnable completeConsumer,</span><br><span class="line">          Consumer&lt;? <span class="keyword">super</span> Subscription&gt; subscriptionConsumer);</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>
<p>这些变种返回对subscription的引用，当你不再需要数据时，可以cancel该subscription。通过cancellation，源会停止生产值，清除它增加的资源。这种cancel和清理由Disposable接口代表。</p>
<h3 id="subscribe-Method-Examples"><a href="#subscribe-Method-Examples" class="headerlink" title="subscribe Method Examples"></a>subscribe Method Examples</h3><p>本节包含subscribe方法的每个签名的最小示例。<br>先是无参方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产三个值</span></span><br><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//订阅</span></span><br><span class="line">ints.subscribe();</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>前面的代码没有产生可见的输出，但是它能工作。该Flux产生了三个值。如果我们提供一个lambda，可以让值可视：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">3</span>); </span><br><span class="line"><span class="comment">//订阅，打印值</span></span><br><span class="line">ints.subscribe(i -&gt; System.out.println(i));</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>输出是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>为了演示下一个方法签名，我们故意引入错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产生四个值</span></span><br><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">4</span>) </span><br><span class="line"><span class="comment">//需要map处理不同的值</span></span><br><span class="line">      .map(i -&gt; &#123; </span><br><span class="line">          <span class="comment">//对于大多数值，返回该值</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">3</span>) <span class="keyword">return</span> i; </span><br><span class="line">        <span class="comment">//强制产生错误</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Got to 4"</span>); </span><br><span class="line">      &#125;);</span><br><span class="line"><span class="comment">//订阅包含了错误处理</span></span><br><span class="line">ints.subscribe(i -&gt; System.out.println(i), </span><br><span class="line">      error -&gt; System.err.println(<span class="string">"Error: "</span> + error));</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<p>我们有两个lambda表达式，一个为期望的内容，一个为错误。输出是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">Error: java.lang.RuntimeException: Got to 4</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<p>subscribe的下一个签名包含completion事件的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">4</span>); </span><br><span class="line">ints.subscribe(i -&gt; System.out.println(i),</span><br><span class="line">    error -&gt; System.err.println(<span class="string">"Error "</span> + error),</span><br><span class="line">    () -&gt; System.out.println(<span class="string">"Done"</span>)); </span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>error信号和completion信号都是终止事件，彼此排斥（不可能同时得到）。要使completion消费者工作，就不能触发错误。<br>completion回调没有输入，由一对空括号表示：它匹配Runnable接口的run方法。前面代码的输出是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">Done</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>
<p>subscribe方法的最后一个签名包含一个Consumer。可以使用Subscription做些事情：执行request(long)，或者cancel()。否则Flux会被挂起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">ints.subscribe(i -&gt; System.out.println(i),</span><br><span class="line">    error -&gt; System.err.println(<span class="string">"Error "</span> + error),</span><br><span class="line">    () -&gt; System.out.println(<span class="string">"Done"</span>),</span><br><span class="line">    <span class="comment">//源最多发射10个元素，实际上，只发射了四个</span></span><br><span class="line">    sub -&gt; sub.request(<span class="number">10</span>)); </span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h3 id="Cancelling-a-subscribe-with-its-Disposable"><a href="#Cancelling-a-subscribe-with-its-Disposable" class="headerlink" title="Cancelling a subscribe() with its Disposable"></a>Cancelling a subscribe() with its Disposable</h3><p>subscribe()的这些变种都有一个Disposable返回类型。在这里，Disposable代表订阅能被取消（通过调用dispose() 方法）。<br>对于Flux和Mono，cancellation是一个信号，源会停止产生数据。但是，不能保证是立竿见影的。有些源生产数据的速度太快，在收到cancel指令前可能已经完成了。<br>Disposables类中有一些实用的工具。Disposables.swap()增加一个Disposable包装器，允许你原子地cancel或者替换一个具体的Disposable。比如在一个UI场景中，每当用户按下一个button，你就可以cancel一个请求，替换成一个新的。</p>
<h3 id="Alternative-to-lambdas-BaseSubscriber"><a href="#Alternative-to-lambdas-BaseSubscriber" class="headerlink" title="Alternative to lambdas: BaseSubscriber"></a>Alternative to lambdas: BaseSubscriber</h3><p>也可以扩展BaseSubscriber，实现订阅功能。<br>比如这样调用一个SampleSubscriber：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SampleSubscriber&lt;Integer&gt; ss = <span class="keyword">new</span> SampleSubscriber&lt;Integer&gt;();</span><br><span class="line">Flux&lt;Integer&gt; ints = Flux.range(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">ints.subscribe(i -&gt; System.out.println(i),</span><br><span class="line">    error -&gt; System.err.println(<span class="string">"Error "</span> + error),</span><br><span class="line">    () -&gt; &#123;System.out.println(<span class="string">"Done"</span>);&#125;,</span><br><span class="line">    s -&gt; s.request(<span class="number">10</span>));</span><br><span class="line">ints.subscribe(ss);</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<p>SampleSubscriber是这样实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BaseSubscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hookOnSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Subscribed"</span>);</span><br><span class="line">		request(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hookOnNext</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">		System.out.println(value);</span><br><span class="line">		request(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<p>SampleSubscriber类扩展了BaseSubscriber，这是自定义Subscribers时，Reactor推荐扩展的抽象类。它提供了可以被覆盖的钩子，以调整subscriber的行为。默认会触发一个unbounded的请求，表现得很像subscribe()。如果你想自定义请求总量，扩展BaseSubscriber就很好。<br>要自定义请求量，最低限度要实现hookOnSubscribe(Subscription subscription) 和hookOnNext(T value)。前面的例子，hookOnSubscribe打印到标准输出，然后发送第一次请求。hookOnNext打印值，执行附加的请求，每次一条。<br>上面SampleSubscriber类的输出是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subscribed</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>
<p>BaseSubscriber类还包含requestUnbounded()方法，可以切换到unbounded模式（相当于request(Long.MAX_VALUE)）。此外还有cancel()方法。<br>它还有这些钩子：hookOnComplete、hookOnError、hookOnCancel和hookFinally（总是在序列终止时被调用，终止类型见SignalType参数）。</p>
<h3 id="On-Backpressure-and-ways-to-reshape-requests"><a href="#On-Backpressure-and-ways-to-reshape-requests" class="headerlink" title="On Backpressure, and ways to reshape requests"></a>On Backpressure, and ways to reshape requests</h3><p>Reactor实现背压的时候，消费者向上游operator发送request。当前请求的和有时候被称为当前demand或者是pending request。上限是Long.MAX_VALUE，代表无限的请求（没有背压）。<br>第一个请求来自最终的subscriber。在订阅的时候，最直接的办法是触发无限的请求：</p>
<ul>
<li>subscribe()和大多数变种</li>
<li>block()、blockFirst()和blockLast()</li>
<li>使用toIterable()/toStream()迭代</li>
</ul>
<p>自定义原始请求的最简单的办法是覆盖BaseSubscriber的hookOnSubscribe方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">    .doOnRequest(r -&gt; System.out.println(<span class="string">"request of "</span> + r))</span><br><span class="line">    .subscribe(<span class="keyword">new</span> BaseSubscriber&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hookOnSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">        request(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hookOnNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cancelling after having received "</span> + integer);</span><br><span class="line">        cancel();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<p>输出是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request of 1</span><br><span class="line">Cancelling after having received 1</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<p>操纵request的时候，你必须小心地产生足够的序列要求，否则你的Flux会被卡住。所以，BaseSubscriber的hookOnSubscribe默认是无限的request。如果你覆盖这个钩子，最少要调用一次request。</p>
<h4 id="Operators-changing-the-demand-from-downstream"><a href="#Operators-changing-the-demand-from-downstream" class="headerlink" title="Operators changing the demand from downstream"></a>Operators changing the demand from downstream</h4><p>要记住，subscribe级别的要求，能被上游的每个operator重新整形。比如buffer(N) operator：如果它收到request(2)，它解释成需要two full buffers。因为buffers认为有N个元素就是满的，该buffer operator使得request成了2 x N。</p>
<p>Prefetch是在内部序列调整初始request的方法，一般来说，默认是32。<br>这些operators一般也实现了补充（replenishing）优化：一旦operator看到25%的prefetch已经完成，就再向上游请求25%。这是一种启发式的优化，让这些operators主动预测即将到来的请求。</p>
<p>也可以直接调整request：limitRate和limitRequest。<br>limitRate(N)拆分下游请求，让他们以较小的批量传播到上游。比如一个100的request，通过limitRate(10)会导致最多10次10个的requests，传播到上游。limitRate实现了上面讨论的补充优化。<br>该operator有个变种，可以调整补充总量：limitRate(highTide, lowTide)，lowTide为0就是严格的highTide批量的请求，而没有补充优化。<br>limitRequest(N)定义下游request的最大总需求。如果单个request不会让总需求超过N，整个request就会传给上游。达到总量，limitRequest认为序列完成，向下游发射onComplete并cancel资源。</p>
<h1 id="Reactor-Core-Features-1"><a href="#Reactor-Core-Features-1" class="headerlink" title="Reactor Core Features"></a>Reactor Core Features</h1><h2 id="Programmatically-creating-a-sequence"><a href="#Programmatically-creating-a-sequence" class="headerlink" title="Programmatically creating a sequence"></a>Programmatically creating a sequence</h2><p>本节介绍如何程序化增加Flux和Mono，以及相关事件（onNext、onError和onComplete）。这些方法都触发了称为sink的事件。实际上是sink的变种。</p>
<h3 id="Synchronous-generate"><a href="#Synchronous-generate" class="headerlink" title="Synchronous generate"></a>Synchronous generate</h3><p>程序化增加Flux的最简单办法是generate方法，接受一个generator 函数。它是同步的，one-by-one 地发射。这是一个SynchronousSink，每次回调最多只能调用一次next()方法。之后可以调用error(Throwable)和complete(),他们是可选的。<br>最有用的变种可能是：让你保持state，还可以引用sink，决定下一个发射什么。该generator函数变成了BiFunction&lt;S, SynchronousSink&lt; T &gt;, S&gt;，其中&lt; S &gt;就是state对象。你可以为初始state提供一个Supplier&lt; S &gt;，你的generator 函数在每一轮都能返回一个新state。<br>比如，使用int做state：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux = Flux.generate(</span><br><span class="line">        <span class="comment">//初始state是0</span></span><br><span class="line">    () -&gt; <span class="number">0</span>, </span><br><span class="line">    (state, sink) -&gt; &#123;</span><br><span class="line">        <span class="comment">//根据state选择发射的内容</span></span><br><span class="line">      sink.next(<span class="string">"3 x "</span> + state + <span class="string">" = "</span> + <span class="number">3</span>*state); </span><br><span class="line">      <span class="comment">//完成</span></span><br><span class="line">      <span class="keyword">if</span> (state == <span class="number">10</span>) sink.complete(); </span><br><span class="line">      <span class="comment">//新的state</span></span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span>; </span><br><span class="line">    &#125;);</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>
<p>上面代码的输出是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">3 x 0 &#x3D; 0</span><br><span class="line">3 x 1 &#x3D; 3</span><br><span class="line">3 x 2 &#x3D; 6</span><br><span class="line">3 x 3 &#x3D; 9</span><br><span class="line">3 x 4 &#x3D; 12</span><br><span class="line">3 x 5 &#x3D; 15</span><br><span class="line">3 x 6 &#x3D; 18</span><br><span class="line">3 x 7 &#x3D; 21</span><br><span class="line">3 x 8 &#x3D; 24</span><br><span class="line">3 x 9 &#x3D; 27</span><br><span class="line">3 x 10 &#x3D; 30</span><br><span class="line">1234567891011</span><br></pre></td></tr></table></figure>
<p>也可以使用可变的。比如下面的代码，使用AtomicLong做state：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux = Flux.generate(</span><br><span class="line">        <span class="comment">//state可变</span></span><br><span class="line">    AtomicLong::<span class="keyword">new</span>, </span><br><span class="line">    (state, sink) -&gt; &#123;</span><br><span class="line">        <span class="comment">//改变了state</span></span><br><span class="line">      <span class="keyword">long</span> i = state.getAndIncrement(); </span><br><span class="line">      sink.next(<span class="string">"3 x "</span> + i + <span class="string">" = "</span> + <span class="number">3</span>*i);</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">10</span>) sink.complete();</span><br><span class="line">      返回新state的同一个实例</span><br><span class="line">      <span class="keyword">return</span> state; </span><br><span class="line">    &#125;);</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>
<p>如果state需要清理资源。可以使用generate(Supplier, BiFunction, Consumer)清理最后一个state实例。<br>下面的例子就包含了一个Consumer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux = Flux.generate(</span><br><span class="line">    AtomicLong::<span class="keyword">new</span>,</span><br><span class="line">      (state, sink) -&gt; &#123; </span><br><span class="line">      <span class="keyword">long</span> i = state.getAndIncrement(); </span><br><span class="line">      sink.next(<span class="string">"3 x "</span> + i + <span class="string">" = "</span> + <span class="number">3</span>*i);</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">10</span>) sink.complete();</span><br><span class="line">      <span class="keyword">return</span> state; </span><br><span class="line">      <span class="comment">//最后输出11</span></span><br><span class="line">    &#125;, (state) -&gt; System.out.println(<span class="string">"state: "</span> + state)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<p>如果该state包含数据库连接，或者其他需要处理的资源。该Consumer表达式可以关闭连接或者其他处理。</p>
<h3 id="Asynchronous-amp-multi-threaded-create"><a href="#Asynchronous-amp-multi-threaded-create" class="headerlink" title="Asynchronous &amp; multi-threaded: create"></a>Asynchronous &amp; multi-threaded: create</h3><p>create比较先进，支持每轮多个发射，甚至支持多线程。<br>它暴露了一个FluxSink，有next、error和complete方法。和generate不同，它没有基于state的变种。在回调中，能触发多线程事件。<br>create可以把现有API带入响应式世界，比如基于监听器的异步API。<br>create不会并行化你的代码，也不会把代码变成异步的。即使使用subscribeOn，也要注意：长时间阻塞create lambda（比如无限循环地调用sink.next(t)）会锁定管道。请求可能永远不会被执行。使用subscribeOn(Scheduler, false) 变种，requestOnSeparateThread = false，create使用Scheduler线程，数据流执行请求也使用同样的线程。</p>
<p>想像你使用listener-based API。它通过chunks处理事件，有两个事件：(1) 数据准备好，(2) 处理完成（terminal事件）。如MyEventListener接口所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyEventListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDataChunk</span><span class="params">(List&lt;T&gt; chunk)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>你可以create一个bridge，放进Flux：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; &#123;</span><br><span class="line">    <span class="comment">//每当myEventProcessor执行时，他们异步执行</span></span><br><span class="line">    myEventProcessor.register( </span><br><span class="line">      <span class="keyword">new</span> MyEventListener&lt;String&gt;() &#123; </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataChunk</span><span class="params">(List&lt;String&gt; chunk)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(String s : chunk) &#123;</span><br><span class="line">              <span class="comment">//chunk中的每个元素，成为Flux中的元素</span></span><br><span class="line">            sink.next(s); </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//processComplete事件转换成onComplete</span></span><br><span class="line">            sink.complete(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>
<p>另外，因为create能bridge异步API，管理背压，你可以通过OverflowStrategy，来优化背压：</p>
<ul>
<li>IGNORE：完全忽略下游的背压请求。当下游队列满时，可能产生IllegalStateException</li>
<li>ERROR：下游跟不上时，IllegalStateException</li>
<li>DROP：下游没准备好接收，就抛弃输入信号</li>
<li>LATEST：下游只读取最新信号</li>
<li>BUFFER（默认）：下游忙不过来就缓冲信号（无限的buffer，可能导致OutOfMemoryError）</li>
</ul>
<p>Mono也有create generator。MonoSink不允许多个发射。在第一个之后drop全部信号。</p>
<h3 id="Asynchronous-but-single-threaded-push"><a href="#Asynchronous-but-single-threaded-push" class="headerlink" title="Asynchronous but single-threaded: push"></a>Asynchronous but single-threaded: push</h3><p>push位于generate和create之间，适合处理单个生产者的事件。和create类似，它支持异步，也可以像create那样管理背压。但是，在某一时刻，只能有一个生产者线程调用next、complete和error。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; bridge = Flux.push(sink -&gt; &#123;</span><br><span class="line">    myEventProcessor.register(</span><br><span class="line">      <span class="keyword">new</span> SingleThreadEventListener&lt;String&gt;() &#123; </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataChunk</span><span class="params">(List&lt;String&gt; chunk)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(String s : chunk) &#123;</span><br><span class="line">              /使用next，从单个监听器线程推送数据给sink</span><br><span class="line">            sink.next(s); </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//complete事件由同一个监听器线程生成</span></span><br><span class="line">            sink.complete(); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//error事件也由同一个监听器线程生成</span></span><br><span class="line">            sink.error(e); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>
<h4 id="An-hybrid-push-pull-model"><a href="#An-hybrid-push-pull-model" class="headerlink" title="An hybrid push/pull model"></a>An hybrid push/pull model</h4><p>大多数Reactor operators，比如create，遵循混合push/pull 模式。尽管大部分处理是异步的（建议使用push方式），但是也有pull组件-request。<br>消费者从源pulls数据，在第一次请求之前不会发射任何数据。然后，只要数据准备好，源就把数据推给消费者，不过要在请求总量范围内。push() 和create()都允许设置一个onRequest消费者，以便管理请求总量、并确保只有在他们等候请求的时候才通过sink推送数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; &#123;</span><br><span class="line">    myMessageProcessor.register(</span><br><span class="line">      <span class="keyword">new</span> MyMessageListener&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(List&lt;String&gt; messages)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(String s : messages) &#123;</span><br><span class="line">              <span class="comment">//之后异步到达的其余消息也被交付</span></span><br><span class="line">            sink.next(s); </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    sink.onRequest(n -&gt; &#123;</span><br><span class="line">        <span class="comment">//请求之后拉消息</span></span><br><span class="line">        List&lt;String&gt; messages = myMessageProcessor.getHistory(n); </span><br><span class="line">        <span class="keyword">for</span>(String s : message) &#123;</span><br><span class="line">            <span class="comment">//如果消息有效，就推给sink</span></span><br><span class="line">           sink.next(s); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure>
<h4 id="Cleaning-up-after-push-or-create"><a href="#Cleaning-up-after-push-or-create" class="headerlink" title="Cleaning up after push() or create()"></a>Cleaning up after push() or create()</h4><p>两个回调，onDispose和onCancel，在终止或者取消的时候执行清理。onDispose在Flux完成、错误退出或者取消后执行。onCancel在onDispose执行之前执行任何取消动作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; &#123;</span><br><span class="line">    sink.onRequest(n -&gt; channel.poll(n))</span><br><span class="line">    <span class="comment">//onCancel先被调用，仅适用cancel信号</span></span><br><span class="line">        .onCancel(() -&gt; channel.cancel())</span><br><span class="line">        <span class="comment">//onDispose被调用，适用complete、error或者cancel信号 </span></span><br><span class="line">        .onDispose(() -&gt; channel.close())  </span><br><span class="line">    &#125;);</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<h3 id="Handle"><a href="#Handle" class="headerlink" title="Handle"></a>Handle</h3><p>handle方法有很大的不同。它是一个实例方法，它是链式的只能在已经存在的源上。支持Mono和Flux。<br>它接近generate，从某种意义上说，它使用了SynchronousSink，只能一个接一个地发射。不过，handle可以从每个源生成任意值，可能会跳过一些元素。可以当作map和filter的组合。它的签名是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Flux&lt;R&gt; <span class="title">handle</span><span class="params">(BiConsumer&lt;T, SynchronousSink&lt;R&gt;&gt;)</span></span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>下来看一个例子，响应式流规范里序列不能有null值。如果你想执行一个map，但是你想使用已经存在的方法做map操作，该方法有时候返回null。<br>比如下面的方法可以安全地用于整数源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">alphabet</span><span class="params">(<span class="keyword">int</span> letterNumber)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (letterNumber &lt; <span class="number">1</span> || letterNumber &gt; <span class="number">26</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> letterIndexAscii = <span class="string">'A'</span> + letterNumber - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">""</span> + (<span class="keyword">char</span>) letterIndexAscii;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用handle删除任何null：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; alphabet = Flux.just(-<span class="number">1</span>, <span class="number">30</span>, <span class="number">13</span>, <span class="number">9</span>, <span class="number">20</span>)</span><br><span class="line">    .handle((i, sink) -&gt; &#123;</span><br><span class="line">        <span class="comment">//映射成字符串</span></span><br><span class="line">        String letter = alphabet(i); </span><br><span class="line">        <span class="keyword">if</span> (letter != <span class="keyword">null</span>) </span><br><span class="line">            <span class="comment">//如果返回null，不调用sink.next</span></span><br><span class="line">            sink.next(letter); </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">alphabet.subscribe(System.out::println);</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<p>程序的输出是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M</span><br><span class="line">I</span><br><span class="line">T</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<h2 id="Threading-and-Schedulers"><a href="#Threading-and-Schedulers" class="headerlink" title="Threading and Schedulers"></a>Threading and Schedulers</h2><p>Reactor是并发不可知论者（concurrency agnostic），它不会强制并发模型。<br>获取Flux或者Mono不意味着它在专用的线程中运行。大多数operators 会在前一个operator工作的线程中执行。如果不指定，源在subscribe() 调用的线程中运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Mono&lt;String&gt;在main线程中组装</span></span><br><span class="line">  <span class="keyword">final</span> Mono&lt;String&gt; mono = Mono.just(<span class="string">"hello "</span>); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; mono</span><br><span class="line">      .map(msg -&gt; msg + <span class="string">"thread "</span>)</span><br><span class="line">      .subscribe(v -&gt; </span><br><span class="line">      <span class="comment">//在Thread-0订阅，于是，map和onNext回调也在该线程中执行</span></span><br><span class="line">          System.out.println(v + Thread.currentThread().getName()) </span><br><span class="line">      )</span><br><span class="line">  ).join();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<p>程序的输出是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello thread Thread-0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>Reactor中，执行模型和在哪儿执行由使用的Scheduler决定。Scheduler的调度职责类似于ExecutorService，不过作为时钟，做了更多。<br>Schedulers类的静态方法可以访问执行上下文：</p>
<ul>
<li>immediate() - 当前线程</li>
<li>single() - 单个、可重用线程。注意，该方法会为所有调用者重用同一个线程，知道它被disposed。如果你想为每个调用生成专有的线程，使用newSingle()方法</li>
<li>elastic() - 一个弹性线程池。按需增加工作线程池，重用空闲的。线程持续空闲太久（默认60秒），会被disposed。I/O阻塞工作可以使用该方法</li>
<li>parallel() - 固定大小的线程池：CPU核数</li>
</ul>
<p>也可以使用Schedulers.fromExecutorService(ExecutorService)方法，从已经存在的ExecutorService增加Scheduler。（也可以从Executor增加）<br>如果阻塞无法避免，可以使用elastic帮助遗留的阻塞代码，single和parallel不行。所以，如果在默认的single和parallel的Schedulers内使用Reactor的阻塞API（block()、blockFirst()和blockLast()，还有迭代的toIterable()和toStream()），会抛IllegalStateException。<br>通过创建实现了NonBlocking标记接口的Thread的实例，也能自定义“仅非阻塞”的Schedulers。</p>
<p>一些operators默认使用特定的Scheduler（你也可以使用不同的）。比如，Flux.interval(Duration.ofMillis(300)) 产生的Flux，默认使用Schedulers.parallel()。你也可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用不同的Scheduler</span></span><br><span class="line">Flux.interval(Duration.ofMillis(<span class="number">300</span>), Schedulers.newSingle(<span class="string">"test"</span>))</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>Reactor提供了两种在响应式链中切换执行上下文（Scheduler）的方法：publishOn和subscribeOn。都接受Scheduler参数，来切换上下文。但是，在链中publishOn的位置很重要，而subscribeOn的位置却不重要。<br>当你链式operators的时候，可以包装很多Flux和Mono。一旦你subscribe了，Subscriber对象的链就生成了，一直回到源。当然你看不到，你能看到的外层的Flux（Mono）和Subscription，但是，实际工作发生在这些中间operator的订阅者那里。<br>有了这些知识，我们仔细看看publishOn和subscribeOn：</p>
<h3 id="publishOn"><a href="#publishOn" class="headerlink" title="publishOn"></a>publishOn</h3><p>publishOn跟其他operator一样，在订阅链的中间。从上游接收信号，下游的operators在相关Scheduler的线程上执行。</p>
<ul>
<li>从Scheduler选择线程，改变执行上下文</li>
<li>onNext使用同一个线程，按顺序执行</li>
<li>或者在特定的Scheduler上工作，或者publishOn之后的operators在相同线程上执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新Scheduler，包含4个线程</span></span><br><span class="line">Scheduler s = Schedulers.newParallel(<span class="string">"parallel-scheduler"</span>, <span class="number">4</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Flux&lt;String&gt; flux = Flux</span><br><span class="line">    .range(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">//第一个map在匿名线程上执行</span></span><br><span class="line">    .map(i -&gt; <span class="number">10</span> + i)  </span><br><span class="line">    <span class="comment">//切换到s包含的线程</span></span><br><span class="line">    .publishOn(s)  </span><br><span class="line">    <span class="comment">//第二个map在s的线程上执行</span></span><br><span class="line">    .map(i -&gt; <span class="string">"value "</span> + i);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅使用了这个匿名线程。print发生在s包含的线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; flux.subscribe(System.out::println));</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<h3 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn"></a>subscribeOn</h3><p>当构造后向的链时，subscribeOn用于subscription处理。不管你在链的任何位置写subscribeOn，它都影响源的上下文。它不影响调用了publishOn的子序列的上下文。</p>
<ul>
<li>改变订阅之上整个链的operators的线程</li>
<li>从Scheduler挑一个线程</li>
</ul>
<p>链中最早的subscribeOn有效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新Scheduler，包含4个线程</span></span><br><span class="line">Scheduler s = Schedulers.newParallel(<span class="string">"parallel-scheduler"</span>, <span class="number">4</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Flux&lt;String&gt; flux = Flux</span><br><span class="line">    .range(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">//第一个map在s的线程上执行</span></span><br><span class="line">    .map(i -&gt; <span class="number">10</span> + i)  </span><br><span class="line">    <span class="comment">//因为subscribeOn，从订阅开始切换序列</span></span><br><span class="line">    .subscribeOn(s)  </span><br><span class="line">    <span class="comment">//和第一个map的执行线程相同</span></span><br><span class="line">    .map(i -&gt; <span class="string">"value "</span> + i);  </span><br><span class="line"><span class="comment">//订阅初始化时使用匿名线程。然后马上切换到s的线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; flux.subscribe(System.out::println)); </span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<h2 id="Handling-Errors"><a href="#Handling-Errors" class="headerlink" title="Handling Errors"></a>Handling Errors</h2><p>响应式系统中，错误是结束事件。当错误发生的时候，它停止序列，传播到链的最后一步，定义的Subscriber的onError方法。<br>此类错误应该由程序处理。比如，显示错误提示，或者发送有意义的错误信息。因此，应该定义onError方法。<br>如果没定义，抛出UnsupportedOperationException。你可以做进一步检测，使用Exceptions.isErrorCallbackNotImplemented方法分流。</p>
<p>Reactor也支持在链的中间处理错误，这就是错误operators。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">//i等于0时抛异常</span></span><br><span class="line">    .map(i -&gt; <span class="string">"100 / "</span> + i + <span class="string">" = "</span> + (<span class="number">100</span> / i)) </span><br><span class="line">    <span class="comment">//错误处理</span></span><br><span class="line">    .onErrorReturn(<span class="string">"Divided by zero :("</span>); </span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>在你学习错误处理operators前，必须记住，错误是序列的结束事件。甚至你使用了错误处理operator，也不会允许原始（original）序列继续。onError信号会作为新序列的开头（回退）</p>
<h3 id="Error-Handling-Operators"><a href="#Error-Handling-Operators" class="headerlink" title="Error Handling Operators"></a>Error Handling Operators</h3><p>你可能熟悉使用try-catch处理异常：</p>
<ul>
<li>Catch，返回静态默认值</li>
<li>Catch，使用回退（fallback）方法执行其他路径</li>
<li>Catch，动态计算fallback值</li>
<li>Catch，包装成一个BusinessException，重新抛出</li>
<li>Catch，记录错误信息，重新抛出</li>
<li>使用finally块或者try-with-resource清理资源</li>
</ul>
<p>所有的这些，在Reactor中都有等价物，有对应的错误处理operators。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; s = Flux.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//会泡异常</span></span><br><span class="line">    .map(v -&gt; doSomethingDangerous(v))</span><br><span class="line">    <span class="comment">//如果一切正常，会执行 </span></span><br><span class="line">    .map(v -&gt; doSecondTransform(v));</span><br><span class="line">s.subscribe(value -&gt; System.out.println(<span class="string">"RECEIVED "</span> + value), <span class="comment">//如果没失败，成功打印</span></span><br><span class="line">            error -&gt; System.err.println(<span class="string">"CAUGHT "</span> + error) <span class="comment">//如果有错误，序列种植，打印失败信息</span></span><br><span class="line">);</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p>和下面的代码类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//如果错误就抛异常</span></span><br><span class="line">        String v1 = doSomethingDangerous(i);</span><br><span class="line">        <span class="comment">//正确就执行</span></span><br><span class="line">        String v2 = doSecondTransform(v1); </span><br><span class="line">        System.out.println(<span class="string">"RECEIVED "</span> + v2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="comment">//异常就跳转到这里</span></span><br><span class="line">    System.err.println(<span class="string">"CAUGHT "</span> + t); </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<h4 id="Static-Fallback-Value"><a href="#Static-Fallback-Value" class="headerlink" title="Static Fallback Value"></a>Static Fallback Value</h4><p>返回静态默认值，相当于onErrorReturn：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingDangerous(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable error) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"RECOVERED"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>变成了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">10</span>)</span><br><span class="line">    .map(<span class="keyword">this</span>::doSomethingDangerous)</span><br><span class="line">    .onErrorReturn(<span class="string">"RECOVERED"</span>);</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>也可以使用任选的Predicate：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">10</span>)</span><br><span class="line">    .map(<span class="keyword">this</span>::doSomethingDangerous)</span><br><span class="line">    <span class="comment">//只有在异常消息是boom10的时候，才返回</span></span><br><span class="line">    .onErrorReturn(e -&gt; e.getMessage().equals(<span class="string">"boom10"</span>), <span class="string">"recovered10"</span>); </span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<h4 id="Fallback-Method"><a href="#Fallback-Method" class="headerlink" title="Fallback Method"></a>Fallback Method</h4><p>如果不想简单返回默认值，而是有其他的处理数据的路径，可以使用onErrorResume：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String v1;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  v1 = callExternalService(<span class="string">"key1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable error) &#123;</span><br><span class="line">  v1 = getFromCache(<span class="string">"key1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String v2;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  v2 = callExternalService(<span class="string">"key2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable error) &#123;</span><br><span class="line">  v2 = getFromCache(<span class="string">"key2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<p>变成了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"key1"</span>, <span class="string">"key2"</span>)</span><br><span class="line"><span class="comment">//对于每个key，异步调用外部服务</span></span><br><span class="line">    .flatMap(k -&gt; callExternalService(k)</span><br><span class="line">    <span class="comment">//如果调用失败，返回缓存值 </span></span><br><span class="line">        .onErrorResume(e -&gt; getFromCache(k)) </span><br><span class="line">    );</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>onErrorResume也有Predicate变种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"timeout1"</span>, <span class="string">"unknown"</span>, <span class="string">"key2"</span>)</span><br><span class="line">    .flatMap(k -&gt; callExternalService(k)</span><br><span class="line">        .onErrorResume(error -&gt; &#123; <span class="comment">//动态选择</span></span><br><span class="line">            <span class="keyword">if</span> (error <span class="keyword">instanceof</span> TimeoutException) <span class="comment">//超时</span></span><br><span class="line">                <span class="keyword">return</span> getFromCache(k);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (error <span class="keyword">instanceof</span> UnknownKeyException)  <span class="comment">//不知道的key</span></span><br><span class="line">                <span class="keyword">return</span> registerNewEntry(k, <span class="string">"DEFAULT"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> Flux.error(error); <span class="comment">//重新抛出异常</span></span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>
<h4 id="Dynamic-Fallback-Value"><a href="#Dynamic-Fallback-Value" class="headerlink" title="Dynamic Fallback Value"></a>Dynamic Fallback Value</h4><p>也可以根据异常，计算fallback值。<br>比如，你返回的MyWrapper类型，专门有一个保存了异常的变种（想一下Future.complete(T success)和Future.completeExceptionally(Throwable error)）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Value v = erroringMethod();</span><br><span class="line">  <span class="keyword">return</span> MyWrapper.fromValue(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable error) &#123;</span><br><span class="line">  <span class="keyword">return</span> MyWrapper.fromError(error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<p>如果使用onErrorResume，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">erroringFlux.onErrorResume(error -&gt; Mono.just( </span><br><span class="line">        <span class="comment">//需要计算异常中的值</span></span><br><span class="line">        MyWrapper.fromError(error) </span><br><span class="line">));</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<h4 id="Catch-and-Rethrow"><a href="#Catch-and-Rethrow" class="headerlink" title="Catch and Rethrow"></a>Catch and Rethrow</h4><p>比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> callExternalService(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable error) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">"oops, SLA exceeded"</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>可以写成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"timeout1"</span>)</span><br><span class="line">    .flatMap(k -&gt; callExternalService(k))</span><br><span class="line">    .onErrorResume(original -&gt; Flux.error(</span><br><span class="line">            <span class="keyword">new</span> BusinessException(<span class="string">"oops, SLA exceeded"</span>, original))</span><br><span class="line">    );</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>也可以这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"timeout1"</span>)</span><br><span class="line">    .flatMap(k -&gt; callExternalService(k))</span><br><span class="line">    .onErrorMap(original -&gt; <span class="keyword">new</span> BusinessException(<span class="string">"oops, SLA exceeded"</span>, original));</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<h4 id="Log-or-React-on-the-Side"><a href="#Log-or-React-on-the-Side" class="headerlink" title="Log or React on the Side"></a>Log or React on the Side</h4><p>如果你希望错误继续传播，不修改序列，只是记录它，可以使用doOnError。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> callExternalService(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException error) &#123;</span><br><span class="line">  <span class="comment">//记录日志</span></span><br><span class="line">  log(<span class="string">"uh oh, falling back, service failed for key "</span> + k);</span><br><span class="line">  <span class="keyword">throw</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p>该doOnError，和前面的其他以doOn为前缀的operators一样，有时候被称为“副作用”。可以用来在不修改序列事件的情况下查看他们。<br>下面的例子还会传播错误，但是我们记录下来了。我们甚至使用了错误统计计数器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LongAdder failureStat = <span class="keyword">new</span> LongAdder();</span><br><span class="line">Flux&lt;String&gt; flux =</span><br><span class="line">Flux.just(<span class="string">"unknown"</span>)</span><br><span class="line">    .flatMap(k -&gt; callExternalService(k) <span class="comment">//调用失败</span></span><br><span class="line">        .doOnError(e -&gt; &#123;</span><br><span class="line">            failureStat.increment();</span><br><span class="line">            log(<span class="string">"uh oh, falling back, service failed for key "</span> + k); <span class="comment">//日志+统计</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//仍然会因为错误而终止，除非我们在这里使用error-recovery operator</span></span><br><span class="line">    );</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<h4 id="Using-Resources-and-the-Finally-Block"><a href="#Using-Resources-and-the-Finally-Block" class="headerlink" title="Using Resources and the Finally Block"></a>Using Resources and the Finally Block</h4><p>对于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stats stats = <span class="keyword">new</span> Stats();</span><br><span class="line">stats.startTimer();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  doSomethingDangerous();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  stats.stopTimerAndRecordTiming();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (SomeAutoCloseable disposableInstance = <span class="keyword">new</span> SomeAutoCloseable()) &#123;</span><br><span class="line">  <span class="keyword">return</span> disposableInstance.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>分别对应doFinally和using。</p>
<p>不管序列终止（onComplete、onError）或者被取消，都会执行doFinally。你可以知道结束类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Stats stats = <span class="keyword">new</span> Stats();</span><br><span class="line">LongAdder statsCancel = <span class="keyword">new</span> LongAdder();</span><br><span class="line"></span><br><span class="line">Flux&lt;String&gt; flux =</span><br><span class="line">Flux.just(<span class="string">"foo"</span>, <span class="string">"bar"</span>)</span><br><span class="line">    .doOnSubscribe(s -&gt; stats.startTimer())</span><br><span class="line">    .doFinally(type -&gt; &#123; <span class="comment">//结束类型SignalType</span></span><br><span class="line">        stats.stopTimerAndRecordTiming();</span><br><span class="line">        <span class="keyword">if</span> (type == SignalType.CANCEL) <span class="comment">//如果是取消，就统计</span></span><br><span class="line">          statsCancel.increment();</span><br><span class="line">    &#125;)</span><br><span class="line">    .take(<span class="number">1</span>);<span class="comment">//发射一个元素就取消</span></span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<p>using用于Flux派生自资源的情况，而且处理完成必须处置资源。<br>让我们使用Disposable替换try-with-resource的AutoCloseable接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AtomicBoolean isDisposed = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">Disposable disposableInstance = <span class="keyword">new</span> Disposable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isDisposed.set(<span class="keyword">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"DISPOSABLE"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<p>我们这样使用using()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux =</span><br><span class="line">Flux.using(</span><br><span class="line">        () -&gt; disposableInstance, <span class="comment">//生成资源，返回我们的Disposable</span></span><br><span class="line">        disposable -&gt; Flux.just(disposable.toString()), <span class="comment">//处理资源，返回Flux&lt;T&gt;</span></span><br><span class="line">        Disposable::dispose <span class="comment">//当前面的Flux结束，清理资源</span></span><br><span class="line">);</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>订阅、执行完该序列后，isDisposed变成了true。</p>
<h4 id="Demonstrating-the-Terminal-Aspect-of-onError"><a href="#Demonstrating-the-Terminal-Aspect-of-onError" class="headerlink" title="Demonstrating the Terminal Aspect of onError"></a>Demonstrating the Terminal Aspect of onError</h4><p>为了证明，发生错误的时候，这些operators导致上游的原始序列结束，看下面使用Flux.interval的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux =</span><br><span class="line">Flux.interval(Duration.ofMillis(<span class="number">250</span>))</span><br><span class="line">    .map(input -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (input &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="string">"tick "</span> + input;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"boom"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .onErrorReturn(<span class="string">"Uh oh"</span>);</span><br><span class="line"></span><br><span class="line">flux.subscribe(System.out::println);</span><br><span class="line">Thread.sleep(<span class="number">2100</span>);</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<p>程序每250毫秒打印一行，输出是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tick 0</span><br><span class="line">tick 1</span><br><span class="line">tick 2</span><br><span class="line">Uh oh</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<h4 id="Retrying"><a href="#Retrying" class="headerlink" title="Retrying"></a>Retrying</h4><p>关于错误处理，还有一个有趣的operator：retry。<br>它会重新订阅上游的Flux。这实际上是一个不同的序列，源已经结束了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Flux.interval(Duration.ofMillis(<span class="number">250</span>))</span><br><span class="line">    .map(input -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (input &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="string">"tick "</span> + input;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"boom"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .retry(<span class="number">1</span>)</span><br><span class="line">    .elapsed() <span class="comment">//把每个值和上一个值发射以后持续的时间相关联</span></span><br><span class="line">    .subscribe(System.out::println, System.err::println); </span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">2100</span>);</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<p>程序的输出是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">259,tick 0</span><br><span class="line">249,tick 1</span><br><span class="line">251,tick 2</span><br><span class="line">506,tick 0 &#x2F;&#x2F;新的interval，从0开始</span><br><span class="line">248,tick 1</span><br><span class="line">253,tick 2</span><br><span class="line">java.lang.RuntimeException: boom</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>
<p>可以看到，retry(1)只重新订阅了一次interval。在第二次，因为还出错，所以错误被传播到下游，序列结束了。<br>还有更先进的retry版本（retryWhen），使用一个伙伴Flux，判断特定的错误是否应该重试。这个伙伴Flux由用户装饰（decorated），自定义retry条件。<br>伙伴Flux是一个Flux，传的参数是Function，返回Publisher&lt;?&gt;。retry这样工作：</p>
<ul>
<li>错误发生，被传给伙伴Flux</li>
<li>如果伙伴Flux发射一个值，retry发生</li>
<li>如果伙伴Flux完成，retry结束，序列完成</li>
<li>如果伙伴Flux抛异常e，retry结束，序列抛e</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux = Flux</span><br><span class="line">    .&lt;String&gt;error(<span class="keyword">new</span> IllegalArgumentException()) </span><br><span class="line">    .doOnError(System.out::println) </span><br><span class="line">    .retryWhen(companion -&gt; companion.take(<span class="number">3</span>)); <span class="comment">//重试3次</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>上面的程序的结果是一个empty Flux，但是它successfully完成了。因为相同Flux上的retry(3) 以最后的错误结束，这个retryWhen例子和retry(3)不完全一样。<br>想达到相同的效果，需要一些技巧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux =</span><br><span class="line">Flux.&lt;String&gt;error(<span class="keyword">new</span> IllegalArgumentException())</span><br><span class="line">    .retryWhen(companion -&gt; companion</span><br><span class="line">    .zipWith(Flux.range(<span class="number">1</span>, <span class="number">4</span>), </span><br><span class="line">          (error, index) -&gt; &#123; </span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">4</span>) <span class="keyword">return</span> index; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">throw</span> Exceptions.propagate(error); </span><br><span class="line">          &#125;)</span><br><span class="line">    );</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<h3 id="Handling-Exceptions-in-Operators-or-Functions"><a href="#Handling-Exceptions-in-Operators-or-Functions" class="headerlink" title="Handling Exceptions in Operators or Functions"></a>Handling Exceptions in Operators or Functions</h3><p>通常，所有的operators自身就包含可能抛异常的代码，调用的用户代码也可能产生类似的失败，所以，都包含失败处理。<br>根据经验，Unchecked Exception总是通过onError传播。比如，在一个map函数内部抛RuntimeException会转换成一个onError事件:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"foo"</span>)</span><br><span class="line">    .map(s -&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(s); &#125;)</span><br><span class="line">    .subscribe(v -&gt; System.out.println(<span class="string">"GOT VALUE"</span>),</span><br><span class="line">               e -&gt; System.out.println(<span class="string">"ERROR: "</span> + e));</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>上面代码的输出是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: java.lang.IllegalArgumentException: foo</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>Reactor定义了一个异常集合（比如OutOfMemoryError），认为他们是fatal，见Exceptions.throwIfFatal方法。这些错误意味着Reactor不能继续运行，会被抛出。<br>在内部，也存在unchecked exception不能被传播的情况（尤其在订阅和请求阶段），由于并发竞争（concurrency races）可能同时满足onError和onComplete条件。当这些竞争发生的时候，错误可能不能传播给dropped。不过，仍然可以通过定制钩子（hook）做一定程度的管理。</p>
<p>你可能会问，那Checked Exceptions呢？<br>比如，你调用了申明了会抛异常的方法，还是应该使用try-catch块处理异常。你有几种选择：</p>
<ul>
<li>捕获异常，从中恢复。sequence继续</li>
<li>捕获异常，包装成unchecked异常，然后抛出（中断sequence）。Exceptions类会为你提供帮助</li>
<li>如果希望返回Flux（比如使用flatMap），可以把异常包装到错误生成中Flux::return Flux.error(checkedException)（序列终止）</li>
</ul>
<p>Reactor提供了Exceptions类，你可以使用它，确保只包装checked异常：</p>
<ul>
<li>必要的时候，使用Exceptions.propagate包装异常。它首先调用throwIfFatal，不会包装RuntimeException</li>
<li>使用Exceptions.unwrap得到未包装的原始异常</li>
</ul>
<p>比如，下面的方法会抛IOException：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"boom "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"OK "</span> + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>现在，你想在map中调用该方法。你必须捕获该异常，而且map函数不能再次抛出它，你可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; converted = Flux</span><br><span class="line">    .range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">    .map(i -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="keyword">return</span> convert(i); &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123; <span class="keyword">throw</span> Exceptions.propagate(e); &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>然后，在订阅的时候，可以得到原始异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">converted.subscribe(</span><br><span class="line">    v -&gt; System.out.println(<span class="string">"RECEIVED: "</span> + v),</span><br><span class="line">    e -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (Exceptions.unwrap(e) <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Something bad happened with I/O"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Something bad happened"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<h2 id="Processors"><a href="#Processors" class="headerlink" title="Processors"></a>Processors</h2><p>Processors是特殊的Publisher，而且也是Subscriber。这就是说，你可以subscribe一个Processor（通常，实现了Flux），你也可以调用方法手工注入数据，或者终止它。<br>有几种类型的Processors，每个都有特殊的语义，在你研究之前，应该问自己几个问题：</p>
<h3 id="Do-I-Need-a-Processor"><a href="#Do-I-Need-a-Processor" class="headerlink" title="Do I Need a Processor?"></a>Do I Need a Processor?</h3><p>应该尽量避免使用Processor，他们不容易正确使用，一般用于特殊场合。<br>如果你认为Processor很适合，就问一下自己，是否尝试过下面两个选择：</p>
<ul>
<li>operator，或者他们的组合是否符合要求</li>
<li>是否可以用 “generator” operator 代替（通常，他们是桥梁API，不是响应式的。提供的sink可以手工填充sequence或者终止它）</li>
</ul>
<h3 id="Safely-Produce-from-Multiple-Threads-by-Using-the-Sink-Facade"><a href="#Safely-Produce-from-Multiple-Threads-by-Using-the-Sink-Facade" class="headerlink" title="Safely Produce from Multiple Threads by Using the Sink Facade"></a>Safely Produce from Multiple Threads by Using the Sink Facade</h3><p>和直接使用Processors相比，更好的办法是调用sink() 方法获取Sink。<br>FluxProcessor的Sink是多线程producers。比如，对于UnicastProcessor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UnicastProcessor&lt;Integer&gt; processor = UnicastProcessor.create();</span><br><span class="line">FluxSink&lt;Integer&gt; sink = processor.sink(overflowStrategy);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>之后，多个生产者线程可以使用sink并发生成数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sink.next(n);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>next方法可能溢出，这由Processor的配置决定：</p>
<ul>
<li>无边界的Processor，自己通过dropping或者buffering处理溢出</li>
<li>有边界的Processor，对于IGNORE策略会阻塞或者旋转（spins），或者定制overflowStrategy</li>
</ul>
<h3 id="Overview-of-Available-Processors"><a href="#Overview-of-Available-Processors" class="headerlink" title="Overview of Available Processors"></a>Overview of Available Processors</h3><p>Reactor自带的Processor大致可分为几类：</p>
<ul>
<li>direct (DirectProcessor、UnicastProcessor)：只能使用Sink提供数据</li>
<li>synchronous (EmitterProcessor、ReplayProcessor)：通过用户交互推送数据，或者通过上游Publisher同步排泄</li>
<li>asynchronous (WorkQueueProcessor、TopicProcessor)：数据来自用户交互，或者多个上游Publishers。他们更强大，有RingBuffer支持</li>
</ul>
<p>异步的最复杂，有许多选项。所以，暴露了Builder接口。而其他简单的只有静态工厂方法。</p>
<h4 id="Direct-Processor"><a href="#Direct-Processor" class="headerlink" title="Direct Processor"></a>Direct Processor</h4><p>Direct Processor可以把信号派发给0个或者多个Subscribers。它不能处理背压。如果最少有一个订阅者请求量少于N，而你推送了N条数据，DirectProcessor就发射IllegalStateException。<br>一旦Processor终止了（一般通过调用它的sink的error(Throwable)或者complete()方法），它允许更多订阅者订阅，但是会立刻重播termination信号。</p>
<h4 id="Unicast-Processor"><a href="#Unicast-Processor" class="headerlink" title="Unicast Processor"></a>Unicast Processor</h4><p>有内部buffer，可以处理背压。但是，最多只能有一个Subscriber。<br>UnicastProcessor有几个选项，所以有多个工厂方法。比如默认的是unbounded，如果Subscriber还没请求数据，不管你给它多少数据，都会被缓存。<br>也可以使用自定义的Queue，如果该队列是有边界的，processor可以拒绝推送数据。也可以定义一个回调，当队列满了就调用该回调。</p>
<h4 id="Emitter-Processor"><a href="#Emitter-Processor" class="headerlink" title="Emitter Processor"></a>Emitter Processor</h4><p>Emitter Processor 能够发射给几个订阅者，并尊重每个订阅者的背压。它还可以订阅一个Publisher，同步地中继它的信号。<br>还没有订阅的时候，根据可配置的bufferSize，它只能接受很少的数据。如果还没有Subscriber消费数据，onNext被阻塞。<br>第一个订阅者会收到这些缓存的数据。它不会为后来的订阅者重播数据，后来的订阅者只能收到以后的新数据。<br>默认地。如果全部订阅者都cancelled，它会清除内部缓存，停止接受新的订阅者。可以通过autoCancel参数修改该行为。</p>
<h4 id="Replay-Processor"><a href="#Replay-Processor" class="headerlink" title="Replay Processor"></a>Replay Processor</h4><p>它缓存数据。或者通过 sink()，或者通过上游Publisher。会为后来的订阅者重播数据。<br>有几种配置：</p>
<ul>
<li>缓存单个元素（cacheLast）</li>
<li>缓存有限的（create(int)），或者无限的（create()）</li>
<li>缓存基于时间的重播窗口（createTimeout(Duration)）</li>
<li>大小和时间的组合（createSizeOrTimeout(int, Duration)）</li>
</ul>
<h4 id="Topic-Processor"><a href="#Topic-Processor" class="headerlink" title="Topic Processor"></a>Topic Processor</h4><p>异步的。当使用shared配置（builder()的share(boolean)选项）生成的时候，可以中继多个上游Publishers。<br>如果你打算并发调用TopicProcessor的onNext、onComplete或者onError方法，或者来自并发的上游Publisher，会强制使用share选项。<br>它可以有多个Subscribers。它会为每个Subscriber关联一个线程，它会一直运行，知道产生onError或者onComplete信号，或者订阅被取消。订阅者的数量由executor选项决定。<br>它包含RingBuffer，存储推送的信号。Subscriber线程会保存RingBuffer的指针。<br>还有autoCancel选项，默认是true，如果源被cancelled，所有的订阅也都被cancelled。</p>
<h4 id="WorkQueue-Processor"><a href="#WorkQueue-Processor" class="headerlink" title="WorkQueue Processor"></a>WorkQueue Processor</h4><p>异步的。当使用shared配置（builder()的share(boolean)选项）生成的时候，可以中继多个上游Publishers。<br>它不完全遵循Reactive Streams规范，所以比TopicProcessor节省资源。它也基于RingBuffer，但是不会为每个订阅者增加线程。所以，它比TopicProcessor容易扩展。<br>来自每个订阅者的请求被集中到一起，被中继的信号只发送给一个Subscriber，采用round-robin模式。<br>它的选项和TopicProcessor相同。<br>它不应该有太多的订阅者。否则可能lock该Processor。</p>
<p>有专属的测试包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.projectreactor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactor-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">12345</span><br></pre></td></tr></table></figure>
<p>主要包括：</p>
<ul>
<li>StepVerifier - 一步一步地测试序列</li>
<li>TestPublisher - 生产数据，测试下游operators的行为</li>
<li>可选Publisher的序列中（比如使用了switchIfEmpty），确保使用某一个</li>
</ul>
<h1 id="Testing-a-Scenario-with-StepVerifier"><a href="#Testing-a-Scenario-with-StepVerifier" class="headerlink" title="Testing a Scenario with StepVerifier"></a>Testing a Scenario with StepVerifier</h1><p>可以一步一步地定义一个测试场景：下一个事件是什么？希望Flux发射一个特定值？或者接下来的300ms什么都不做？他们都可以通过StepVerifier实现。<br>比如下面的Flux装饰代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Flux&lt;T&gt; <span class="title">appendBoomError</span><span class="params">(Flux&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source.concatWith(Mono.error(<span class="keyword">new</span> IllegalArgumentException(<span class="string">"boom"</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>为了测试，你想这样验证：首先发射foo，然后发射bar，然后是产生错误消息boom。<br>使用StepVerifier，测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAppendBoomError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要一个源Flux</span></span><br><span class="line">  Flux&lt;String&gt; source = Flux.just(<span class="string">"foo"</span>, <span class="string">"bar"</span>); </span><br><span class="line"></span><br><span class="line">  StepVerifier.create( <span class="comment">//增加StepVerifier builder</span></span><br><span class="line">    appendBoomError(source)) </span><br><span class="line">    .expectNext(<span class="string">"foo"</span>) <span class="comment">//第一个信号是onNext，值是foo</span></span><br><span class="line">    .expectNext(<span class="string">"bar"</span>)</span><br><span class="line">    .expectErrorMessage(<span class="string">"boom"</span>) <span class="comment">//最后一个信号是onError，包含一个boom消息</span></span><br><span class="line">    .verify(); <span class="comment">//触发测试</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<p>该API是一个builder。通过增加StepVerifier，把序列传给它来做测试。它提供了下列方法：</p>
<ul>
<li>表达式expectations是关于下一个信号的。如果收到其他信号（或者内容不匹配），测试失败，并带有有意义的AssertionError。比如你可以使用expectNext(T…) ，或者expectNextCount(long)</li>
<li>Consume下一个信号。当你想跳过部分序列，或者想为信号内容使用自定义的assertion的时候（比如，想检查onNext事件，并且发射了包含5条数据的列表）。比如你可以使用consumeNextWith(Consumer)</li>
<li>其他操作，比如暂停或者运行任意代码。比如，如果想操纵某上下文或者状态，可能会使用thenAwait(Duration)和then(Runnable)</li>
</ul>
<p>对于终止事件，相应的expectation方法是expectComplete()和expectError()的变种。最后，你能做些附加配置，然后触发验证，一般是使用verify()或者变种。<br>如果验证失败，抛出AssertionError。</p>
<h2 id="Better-identifying-test-failures"><a href="#Better-identifying-test-failures" class="headerlink" title="Better identifying test failures"></a>Better identifying test failures</h2><ul>
<li>as(String)：可用于大多数expect*的后面，描述前面的expectation。如果失败，错误消息包含该描述。终止expectations和verify不能被描述</li>
<li>StepVerifierOptions.create().scenarioName(String)：使用StepVerifierOptions增加StepVerifier，可以使用scenarioName给整个场景命名。它也会在错误消息中使用</li>
</ul>
<p>注意，只有在产生自己的AssertionError的StepVerifier方法，会在消息中使用description/name。</p>
<h1 id="Manipulating-Time"><a href="#Manipulating-Time" class="headerlink" title="Manipulating Time"></a>Manipulating Time</h1><p>基于时间的operators，可以使用StepVerifier.withVirtualTime。以避免测试长时间运行。<br>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StepVerifier.withVirtualTime(() -&gt; Mono.delay(Duration.ofDays(<span class="number">1</span>)))</span><br><span class="line"><span class="comment">//... continue expectations here</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>虚拟时间特性，在Schedulers工厂中加入一个定制Scheduler。由于时间operators默认使用Schedulers.parallel()，现在替换成了VirtualTimeScheduler。重要的是：在虚拟时间调度器激活之后，再实例化该operator。<br>为提高成功率，该StepVerifier的输入不是简单的Flux，而是Supplier。这样会延迟生成要测试的flux的实例。<br>一定要确保Supplier&lt;Publisher&lt; T &gt;&gt;的延迟性。该Flux的实例化应该在lambda内。</p>
<p>有两个和时间相关的expectation，不管是否使用虚拟时间都有效：</p>
<ul>
<li>thenAwait(Duration)：暂停评估步骤</li>
<li>expectNoEvent(Duration)：序列可以继续，如果给定时间内有事件，就失败</li>
</ul>
<p>这两个方法在经典方式下会将线程暂停一些时间，在虚拟时间方式下也会改进虚拟时钟。<br>expectNoEvent会认为subscription也是一个事件。如果在第一步使用了它，一般会失败，这是因为检测到了subscription信号。此时，可以使用expectSubscription().expectNoEvent(duration)。</p>
<p>为了快速评估Mono.delay的行为，可以这样写代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StepVerifier.withVirtualTime(() -&gt; Mono.delay(Duration.ofDays(<span class="number">1</span>)))</span><br><span class="line">    .expectSubscription() </span><br><span class="line">    .expectNoEvent(Duration.ofDays(<span class="number">1</span>)) <span class="comment">//1天内什么都没发生</span></span><br><span class="line">    .expectNext(<span class="number">0L</span>) <span class="comment">//然后发射0</span></span><br><span class="line">    .verifyComplete(); <span class="comment">//完成</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<h1 id="Performing-Post-execution-Assertions-with-StepVerifier"><a href="#Performing-Post-execution-Assertions-with-StepVerifier" class="headerlink" title="Performing Post-execution Assertions with StepVerifier"></a>Performing Post-execution Assertions with StepVerifier</h1><p>在最后一个expectation之后，如果想使用assertion API ，而不是触发 verify()。可以使用verifyThenAssertThat()。<br>它返回StepVerifier.Assertions 对象。这样，在场景胜利结束后，可以断言一些状态元素。</p>
<h1 id="Testing-the-Context"><a href="#Testing-the-Context" class="headerlink" title="Testing the Context"></a>Testing the Context</h1><p>对于上下文的传播，有一些expectations：</p>
<ul>
<li>expectAccessibleContext：返回一个ContextExpectations，用来设置expectations 。确保调用then()以返回sequence expectations的设置</li>
<li>expectNoAccessibleContext：希望测试operators链上，不传播上下文</li>
</ul>
<p>可以使用StepVerifierOptions，给StepVerifier关联一个测试初始上下文。代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StepVerifier.create(Mono.just(<span class="number">1</span>).map(i -&gt; i + <span class="number">10</span>),</span><br><span class="line">				StepVerifierOptions.create().withInitialContext(Context.of(<span class="string">"foo"</span>, <span class="string">"bar"</span>))) <span class="comment">//有初始Context</span></span><br><span class="line">		            .expectAccessibleContext() <span class="comment">//上下文传播expectations</span></span><br><span class="line">		            .contains(<span class="string">"foo"</span>, <span class="string">"bar"</span>) <span class="comment">//上下文中，key foo的值是bar</span></span><br><span class="line">		            .then() <span class="comment">//切换回正常expectations</span></span><br><span class="line">		            .expectNext(<span class="number">11</span>)</span><br><span class="line">		            .verifyComplete();<span class="comment">//结束 </span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<h1 id="Manually-Emitting-with-TestPublisher"><a href="#Manually-Emitting-with-TestPublisher" class="headerlink" title="Manually Emitting with TestPublisher"></a>Manually Emitting with TestPublisher</h1><p>对于更高级的测试用例，可能需要完全掌握数据源，以便触发想要的信号。<br>或者你实现了自己的operator，想验证是否满足Reactive Streams规范。</p>
<p>对此，提供了TestPublisher类。它是Publisher ，可以用程序触发以下信号：</p>
<ul>
<li>next(T)、next(T, T…)：触发1-n个onNext信号</li>
<li>emit(T…) ：发射数据，然后complete()</li>
<li>complete() ：使用onComplete信号结束</li>
<li>error(Throwable)：使用onError信号结束</li>
</ul>
<p>可以通过create工厂方法获得TestPublisher。也可以使用createNonCompliant工厂方法，它从TestPublisher.Violation枚举中接受一个值或者多个值。这些值规定了发布者可以忽略规范的哪些部分：</p>
<ul>
<li>REQUEST_OVERFLOW：即使请求不足，也允许调用next，不会抛IllegalStateException</li>
<li>ALLOW_NULL：对于null，也允许调用next，不会抛NullPointerException</li>
<li>CLEANUP_ON_TERMINATE：允许发送多次终止信号。包括complete()、 error()和emit()</li>
<li>DEFER_CANCELLATION：允许忽略cancel信号，继续发送信号</li>
</ul>
<p>TestPublisher会在订阅以后跟踪内部状态，以使用assert*方法。</p>
<h1 id="Checking-the-Execution-Path-with-PublisherProbe"><a href="#Checking-the-Execution-Path-with-PublisherProbe" class="headerlink" title="Checking the Execution Path with PublisherProbe"></a>Checking the Execution Path with PublisherProbe</h1><p>当构建复杂operators链的时候，可能会有多个执行路径，对应不同的子序列。<br>大多数情况下，这些子序列能够生产足够的onNext信号，可以执行到最后。<br>比如下面的例子，如果源是空的，就使用switchIfEmpty：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Flux&lt;String&gt; <span class="title">processOrFallback</span><span class="params">(Mono&lt;String&gt; source, Publisher&lt;String&gt; fallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source</span><br><span class="line">            .flatMapMany(phrase -&gt; Flux.fromArray(phrase.split(<span class="string">"\\s+"</span>)))</span><br><span class="line">            .switchIfEmpty(fallback);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>很容易测试switchIfEmpty对应的逻辑分支：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitPathIsUsed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StepVerifier.create(processOrFallback(Mono.just(<span class="string">"just a  phrase with    tabs!"</span>), Mono.just(<span class="string">"EMPTY_PHRASE"</span>)))</span><br><span class="line">                .expectNext(<span class="string">"just"</span>, <span class="string">"a"</span>, <span class="string">"phrase"</span>, <span class="string">"with"</span>, <span class="string">"tabs!"</span>)</span><br><span class="line">                .verifyComplete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEmptyPathIsUsed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StepVerifier.create(processOrFallback(Mono.empty(), Mono.just(<span class="string">"EMPTY_PHRASE"</span>)))</span><br><span class="line">                .expectNext(<span class="string">"EMPTY_PHRASE"</span>)</span><br><span class="line">                .verifyComplete();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<p>但是，考虑另一个例子，方法生产的是Mono。它等待源完成，执行附加任务，然后完成。如果源是空的，执行Runnable类型的任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Mono&lt;String&gt; <span class="title">executeCommand</span><span class="params">(String command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Mono.just(command + <span class="string">" DONE"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">processOrFallback</span><span class="params">(Mono&lt;String&gt; commandSource, Mono&lt;Void&gt; doWhenEmpty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commandSource</span><br><span class="line">            .flatMap(command -&gt; executeCommand(command).then()) <span class="comment">//then()忘记了command的返回。它只关心已经完成了</span></span><br><span class="line">            .switchIfEmpty(doWhenEmpty); <span class="comment">//如何区分两个都是空序列的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<p>为了验证processOrFallback确实执行了doWhenEmpty路径，你需要写boilerplate。就是说，你需要一个Mono ：</p>
<ul>
<li>它确实被订阅了</li>
<li>整个处理结束后，断言该事实</li>
</ul>
<p>在 3.1之前，你需要为每个想要断言的状态，手工维护一个AtomicBoolean，并将相应的doOn*回调附加到要评估的发布者。从3.1.0开始，可以使用PublisherProbe：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCommandEmptyPathIsUsed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PublisherProbe&lt;Void&gt; probe = PublisherProbe.empty(); <span class="comment">//翻译空序列</span></span><br><span class="line"></span><br><span class="line">    StepVerifier.create(processOrFallback(Mono.empty(), probe.mono())) <span class="comment">//使用probe.mono()代替Mono&lt;Void&gt; </span></span><br><span class="line">                .verifyComplete();</span><br><span class="line"></span><br><span class="line">    probe.assertWasSubscribed(); <span class="comment">//序列完成后，确保使用了probe</span></span><br><span class="line">    probe.assertWasRequested(); <span class="comment">//以及实际请求的数据</span></span><br><span class="line">    probe.assertWasNotCancelled(); <span class="comment">//没有被取消</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>
<p>本方法，对Flux&lt; T &gt;也有效。对于需要探测执行路径，也需要探测数据的情况，你可以使用PublisherProbe.of(Publisher)包装任何Publisher&lt; T &gt;。</p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    
<nav id="article-nav">
    
        <a href="/wiki/netty/Netty-new%E7%AC%94%E8%AE%B0/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">上一篇</strong>
            <div class="article-nav-title">
                
                    Netty-ByteBuf
                
            </div>
        </a>
    
    
        <a href="/wiki/dubbo/dubbo%20%E9%97%AE%E9%A2%98/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">下一篇</strong>
            <div class="article-nav-title">dubbo 问题</div>
        </a>
    
</nav>





    
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     
</section>
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            Gordon gy &copy; 2020 
            <br> Powered by <a href="http://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten" target="_blank" rel="external nofollow noopener noreferrer">wikitten</a>
            
                <br>
                <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i> <span id="busuanzi_value_site_pv"></span></span>
                &nbsp;|&nbsp;
                <span id="busuanzi_container_site_pv"><i class="fa fa-user"></i> <span id="busuanzi_value_site_uv"></span></span>
            
        </div>
    </div>
</footer>

        

    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
</body>
